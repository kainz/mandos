#!/usr/bin/python
# -*- mode: python; coding: utf-8; after-save-hook: (lambda () (let ((command (if (and (boundp 'tramp-file-name-structure) (string-match (car tramp-file-name-structure) (buffer-file-name))) (tramp-file-name-localname (tramp-dissect-file-name (buffer-file-name))) (buffer-file-name)))) (if (= (shell-command (format "%s --check" (shell-quote-argument command)) "*Test*") 0) (let ((w (get-buffer-window "*Test*"))) (if w (delete-window w)) (kill-buffer "*Test*")) (display-buffer "*Test*")))); -*-
#
# Mandos Monitor - Control and monitor the Mandos server
#
# Copyright © 2008-2019 Teddy Hogeborn
# Copyright © 2008-2019 Björn Påhlsson
#
# This file is part of Mandos.
#
# Mandos is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
#     Mandos is distributed in the hope that it will be useful, but
#     WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Mandos.  If not, see <http://www.gnu.org/licenses/>.
#
# Contact the authors at <mandos@recompile.se>.
#

from __future__ import (division, absolute_import, print_function,
                        unicode_literals)

try:
    from future_builtins import *
except ImportError:
    pass

import sys
import argparse
import locale
import datetime
import re
import os
import collections
import json
import unittest
import logging
import io
import tempfile
import contextlib

import dbus

# Show warnings by default
if not sys.warnoptions:
    import warnings
    warnings.simplefilter("default")

log = logging.getLogger(sys.argv[0])
logging.basicConfig(level="INFO", # Show info level messages
                    format="%(message)s") # Show basic log messages

logging.captureWarnings(True)   # Show warnings via the logging system

if sys.version_info.major == 2:
    str = unicode

locale.setlocale(locale.LC_ALL, "")

dbus_busname_domain = "se.recompile"
dbus_busname = dbus_busname_domain + ".Mandos"
server_dbus_path = "/"
server_dbus_interface = dbus_busname_domain + ".Mandos"
client_dbus_interface = dbus_busname_domain + ".Mandos.Client"
del dbus_busname_domain
version = "1.8.3"


try:
    dbus.OBJECT_MANAGER_IFACE
except AttributeError:
    dbus.OBJECT_MANAGER_IFACE = "org.freedesktop.DBus.ObjectManager"


def main():
    parser = argparse.ArgumentParser()

    add_command_line_options(parser)

    options = parser.parse_args()

    check_option_syntax(parser, options)

    clientnames = options.client

    if options.debug:
        log.setLevel(logging.DEBUG)

    bus = dbus.SystemBus()

    mandos_dbus_object = get_mandos_dbus_object(bus)

    mandos_serv = dbus.Interface(
        mandos_dbus_object, dbus_interface=server_dbus_interface)
    mandos_serv_object_manager = dbus.Interface(
        mandos_dbus_object, dbus_interface=dbus.OBJECT_MANAGER_IFACE)

    managed_objects = get_managed_objects(mandos_serv_object_manager)

    all_clients = {}
    for path, ifs_and_props in managed_objects.items():
        try:
            all_clients[path] = ifs_and_props[client_dbus_interface]
        except KeyError:
            pass

    # Compile dict of (clientpath: properties) to process
    if not clientnames:
        clients = all_clients
    else:
        clients = {}
        for name in clientnames:
            for objpath, properties in all_clients.items():
                if properties["Name"] == name:
                    clients[objpath] = properties
                    break
            else:
                log.critical("Client not found on server: %r", name)
                sys.exit(1)

    commands = commands_from_options(options)

    for command in commands:
        command.run(clients, bus, mandos_serv)


def add_command_line_options(parser):
    parser.add_argument("--version", action="version",
                        version="%(prog)s {}".format(version),
                        help="show version number and exit")
    parser.add_argument("-a", "--all", action="store_true",
                        help="Select all clients")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Print all fields")
    parser.add_argument("-j", "--dump-json", action="store_true",
                        help="Dump client data in JSON format")
    enable_disable = parser.add_mutually_exclusive_group()
    enable_disable.add_argument("-e", "--enable", action="store_true",
                                help="Enable client")
    enable_disable.add_argument("-d", "--disable",
                                action="store_true",
                                help="disable client")
    parser.add_argument("-b", "--bump-timeout", action="store_true",
                        help="Bump timeout for client")
    start_stop_checker = parser.add_mutually_exclusive_group()
    start_stop_checker.add_argument("--start-checker",
                                    action="store_true",
                                    help="Start checker for client")
    start_stop_checker.add_argument("--stop-checker",
                                    action="store_true",
                                    help="Stop checker for client")
    parser.add_argument("-V", "--is-enabled", action="store_true",
                        help="Check if client is enabled")
    parser.add_argument("-r", "--remove", action="store_true",
                        help="Remove client")
    parser.add_argument("-c", "--checker",
                        help="Set checker command for client")
    parser.add_argument("-t", "--timeout", type=string_to_delta,
                        help="Set timeout for client")
    parser.add_argument("--extended-timeout", type=string_to_delta,
                        help="Set extended timeout for client")
    parser.add_argument("-i", "--interval", type=string_to_delta,
                        help="Set checker interval for client")
    approve_deny_default = parser.add_mutually_exclusive_group()
    approve_deny_default.add_argument(
        "--approve-by-default", action="store_true",
        default=None, dest="approved_by_default",
        help="Set client to be approved by default")
    approve_deny_default.add_argument(
        "--deny-by-default", action="store_false",
        dest="approved_by_default",
        help="Set client to be denied by default")
    parser.add_argument("--approval-delay", type=string_to_delta,
                        help="Set delay before client approve/deny")
    parser.add_argument("--approval-duration", type=string_to_delta,
                        help="Set duration of one client approval")
    parser.add_argument("-H", "--host", help="Set host for client")
    parser.add_argument("-s", "--secret",
                        type=argparse.FileType(mode="rb"),
                        help="Set password blob (file) for client")
    approve_deny = parser.add_mutually_exclusive_group()
    approve_deny.add_argument(
        "-A", "--approve", action="store_true",
        help="Approve any current client request")
    approve_deny.add_argument("-D", "--deny", action="store_true",
                              help="Deny any current client request")
    parser.add_argument("--debug", action="store_true",
                        help="Debug mode (show D-Bus commands)")
    parser.add_argument("--check", action="store_true",
                        help="Run self-test")
    parser.add_argument("client", nargs="*", help="Client name")


def string_to_delta(interval):
    """Parse a string and return a datetime.timedelta"""

    try:
        return rfc3339_duration_to_delta(interval)
    except ValueError as e:
        log.warning("%s - Parsing as pre-1.6.1 interval instead",
                    ' '.join(e.args))
    return parse_pre_1_6_1_interval(interval)


def rfc3339_duration_to_delta(duration):
    """Parse an RFC 3339 "duration" and return a datetime.timedelta

    >>> rfc3339_duration_to_delta("P7D")
    datetime.timedelta(7)
    >>> rfc3339_duration_to_delta("PT60S")
    datetime.timedelta(0, 60)
    >>> rfc3339_duration_to_delta("PT60M")
    datetime.timedelta(0, 3600)
    >>> rfc3339_duration_to_delta("P60M")
    datetime.timedelta(1680)
    >>> rfc3339_duration_to_delta("PT24H")
    datetime.timedelta(1)
    >>> rfc3339_duration_to_delta("P1W")
    datetime.timedelta(7)
    >>> rfc3339_duration_to_delta("PT5M30S")
    datetime.timedelta(0, 330)
    >>> rfc3339_duration_to_delta("P1DT3M20S")
    datetime.timedelta(1, 200)
    >>> # Can not be empty:
    >>> rfc3339_duration_to_delta("")
    Traceback (most recent call last):
    ...
    ValueError: Invalid RFC 3339 duration: ""
    >>> # Must start with "P":
    >>> rfc3339_duration_to_delta("1D")
    Traceback (most recent call last):
    ...
    ValueError: Invalid RFC 3339 duration: "1D"
    >>> # Must use correct order
    >>> rfc3339_duration_to_delta("PT1S2M")
    Traceback (most recent call last):
    ...
    ValueError: Invalid RFC 3339 duration: "PT1S2M"
    >>> # Time needs time marker
    >>> rfc3339_duration_to_delta("P1H2S")
    Traceback (most recent call last):
    ...
    ValueError: Invalid RFC 3339 duration: "P1H2S"
    >>> # Weeks can not be combined with anything else
    >>> rfc3339_duration_to_delta("P1D2W")
    Traceback (most recent call last):
    ...
    ValueError: Invalid RFC 3339 duration: "P1D2W"
    >>> rfc3339_duration_to_delta("P2W2H")
    Traceback (most recent call last):
    ...
    ValueError: Invalid RFC 3339 duration: "P2W2H"
    """

    # Parsing an RFC 3339 duration with regular expressions is not
    # possible - there would have to be multiple places for the same
    # values, like seconds.  The current code, while more esoteric, is
    # cleaner without depending on a parsing library.  If Python had a
    # built-in library for parsing we would use it, but we'd like to
    # avoid excessive use of external libraries.

    # New type for defining tokens, syntax, and semantics all-in-one
    Token = collections.namedtuple("Token", (
        "regexp",  # To match token; if "value" is not None, must have
                   # a "group" containing digits
        "value",   # datetime.timedelta or None
        "followers"))           # Tokens valid after this token
    # RFC 3339 "duration" tokens, syntax, and semantics; taken from
    # the "duration" ABNF definition in RFC 3339, Appendix A.
    token_end = Token(re.compile(r"$"), None, frozenset())
    token_second = Token(re.compile(r"(\d+)S"),
                         datetime.timedelta(seconds=1),
                         frozenset((token_end, )))
    token_minute = Token(re.compile(r"(\d+)M"),
                         datetime.timedelta(minutes=1),
                         frozenset((token_second, token_end)))
    token_hour = Token(re.compile(r"(\d+)H"),
                       datetime.timedelta(hours=1),
                       frozenset((token_minute, token_end)))
    token_time = Token(re.compile(r"T"),
                       None,
                       frozenset((token_hour, token_minute,
                                  token_second)))
    token_day = Token(re.compile(r"(\d+)D"),
                      datetime.timedelta(days=1),
                      frozenset((token_time, token_end)))
    token_month = Token(re.compile(r"(\d+)M"),
                        datetime.timedelta(weeks=4),
                        frozenset((token_day, token_end)))
    token_year = Token(re.compile(r"(\d+)Y"),
                       datetime.timedelta(weeks=52),
                       frozenset((token_month, token_end)))
    token_week = Token(re.compile(r"(\d+)W"),
                       datetime.timedelta(weeks=1),
                       frozenset((token_end, )))
    token_duration = Token(re.compile(r"P"), None,
                           frozenset((token_year, token_month,
                                      token_day, token_time,
                                      token_week)))
    # Define starting values:
    # Value so far
    value = datetime.timedelta()
    found_token = None
    # Following valid tokens
    followers = frozenset((token_duration, ))
    # String left to parse
    s = duration
    # Loop until end token is found
    while found_token is not token_end:
        # Search for any currently valid tokens
        for token in followers:
            match = token.regexp.match(s)
            if match is not None:
                # Token found
                if token.value is not None:
                    # Value found, parse digits
                    factor = int(match.group(1), 10)
                    # Add to value so far
                    value += factor * token.value
                # Strip token from string
                s = token.regexp.sub("", s, 1)
                # Go to found token
                found_token = token
                # Set valid next tokens
                followers = found_token.followers
                break
        else:
            # No currently valid tokens were found
            raise ValueError("Invalid RFC 3339 duration: \"{}\""
                             .format(duration))
    # End token found
    return value


def parse_pre_1_6_1_interval(interval):
    """Parse an interval string as documented by Mandos before 1.6.1,
    and return a datetime.timedelta

    >>> parse_pre_1_6_1_interval('7d')
    datetime.timedelta(7)
    >>> parse_pre_1_6_1_interval('60s')
    datetime.timedelta(0, 60)
    >>> parse_pre_1_6_1_interval('60m')
    datetime.timedelta(0, 3600)
    >>> parse_pre_1_6_1_interval('24h')
    datetime.timedelta(1)
    >>> parse_pre_1_6_1_interval('1w')
    datetime.timedelta(7)
    >>> parse_pre_1_6_1_interval('5m 30s')
    datetime.timedelta(0, 330)
    >>> parse_pre_1_6_1_interval('')
    datetime.timedelta(0)
    >>> # Ignore unknown characters, allow any order and repetitions
    >>> parse_pre_1_6_1_interval('2dxy7zz11y3m5m')
    datetime.timedelta(2, 480, 18000)

    """

    value = datetime.timedelta(0)
    regexp = re.compile(r"(\d+)([dsmhw]?)")

    for num, suffix in regexp.findall(interval):
        if suffix == "d":
            value += datetime.timedelta(int(num))
        elif suffix == "s":
            value += datetime.timedelta(0, int(num))
        elif suffix == "m":
            value += datetime.timedelta(0, 0, 0, 0, int(num))
        elif suffix == "h":
            value += datetime.timedelta(0, 0, 0, 0, 0, int(num))
        elif suffix == "w":
            value += datetime.timedelta(0, 0, 0, 0, 0, 0, int(num))
        elif suffix == "":
            value += datetime.timedelta(0, 0, 0, int(num))
    return value


def check_option_syntax(parser, options):
    """Apply additional restrictions on options, not expressible in
argparse"""

    def has_actions(options):
        return any((options.enable,
                    options.disable,
                    options.bump_timeout,
                    options.start_checker,
                    options.stop_checker,
                    options.is_enabled,
                    options.remove,
                    options.checker is not None,
                    options.timeout is not None,
                    options.extended_timeout is not None,
                    options.interval is not None,
                    options.approved_by_default is not None,
                    options.approval_delay is not None,
                    options.approval_duration is not None,
                    options.host is not None,
                    options.secret is not None,
                    options.approve,
                    options.deny))

    if has_actions(options) and not (options.client or options.all):
        parser.error("Options require clients names or --all.")
    if options.verbose and has_actions(options):
        parser.error("--verbose can only be used alone.")
    if options.dump_json and (options.verbose
                              or has_actions(options)):
        parser.error("--dump-json can only be used alone.")
    if options.all and not has_actions(options):
        parser.error("--all requires an action.")
    if options.is_enabled and len(options.client) > 1:
        parser.error("--is-enabled requires exactly one client")
    if options.remove:
        options.remove = False
        if has_actions(options) and not options.deny:
            parser.error("--remove can only be combined with --deny")
        options.remove = True


def get_mandos_dbus_object(bus):
    log.debug("D-Bus: Connect to: (busname=%r, path=%r)",
              dbus_busname, server_dbus_path)
    with if_dbus_exception_log_with_exception_and_exit(
            "Could not connect to Mandos server: %s"):
        mandos_dbus_object = bus.get_object(dbus_busname,
                                            server_dbus_path)
    return mandos_dbus_object


@contextlib.contextmanager
def if_dbus_exception_log_with_exception_and_exit(*args, **kwargs):
    try:
        yield
    except dbus.exceptions.DBusException as e:
        log.critical(*(args + (e,)), **kwargs)
        sys.exit(1)


def get_managed_objects(object_manager):
    log.debug("D-Bus: %s:%s:%s.GetManagedObjects()", dbus_busname,
              server_dbus_path, dbus.OBJECT_MANAGER_IFACE)
    with if_dbus_exception_log_with_exception_and_exit(
            "Failed to access Mandos server through D-Bus:\n%s"):
        with SilenceLogger("dbus.proxies"):
            managed_objects = object_manager.GetManagedObjects()
    return managed_objects


class SilenceLogger(object):
    "Simple context manager to silence a particular logger"
    def __init__(self, loggername):
        self.logger = logging.getLogger(loggername)

    def __enter__(self):
        self.logger.addFilter(self.nullfilter)
        return self

    class NullFilter(logging.Filter):
        def filter(self, record):
            return False

    nullfilter = NullFilter()

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.logger.removeFilter(self.nullfilter)


def commands_from_options(options):

    commands = []

    if options.is_enabled:
        commands.append(command.IsEnabled())

    if options.approve:
        commands.append(command.Approve())

    if options.deny:
        commands.append(command.Deny())

    if options.remove:
        commands.append(command.Remove())

    if options.dump_json:
        commands.append(command.DumpJSON())

    if options.enable:
        commands.append(command.Enable())

    if options.disable:
        commands.append(command.Disable())

    if options.bump_timeout:
        commands.append(command.BumpTimeout())

    if options.start_checker:
        commands.append(command.StartChecker())

    if options.stop_checker:
        commands.append(command.StopChecker())

    if options.approved_by_default is not None:
        if options.approved_by_default:
            commands.append(command.ApproveByDefault())
        else:
            commands.append(command.DenyByDefault())

    if options.checker is not None:
        commands.append(command.SetChecker(options.checker))

    if options.host is not None:
        commands.append(command.SetHost(options.host))

    if options.secret is not None:
        commands.append(command.SetSecret(options.secret))

    if options.timeout is not None:
        commands.append(command.SetTimeout(options.timeout))

    if options.extended_timeout:
        commands.append(
            command.SetExtendedTimeout(options.extended_timeout))

    if options.interval is not None:
        commands.append(command.SetInterval(options.interval))

    if options.approval_delay is not None:
        commands.append(
            command.SetApprovalDelay(options.approval_delay))

    if options.approval_duration is not None:
        commands.append(
            command.SetApprovalDuration(options.approval_duration))

    # If no command option has been given, show table of clients,
    # optionally verbosely
    if not commands:
        commands.append(command.PrintTable(verbose=options.verbose))

    return commands


class command(object):
    """A namespace for command classes"""

    class Base(object):
        """Abstract base class for commands"""
        def run(self, clients, bus=None, mandos=None):
            """Normal commands should implement run_on_one_client(),
but commands which want to operate on all clients at the same time can
override this run() method instead.
"""
            self.mandos = mandos
            for clientpath, properties in clients.items():
                log.debug("D-Bus: Connect to: (busname=%r, path=%r)",
                          dbus_busname, str(clientpath))
                client = bus.get_object(dbus_busname, clientpath)
                self.run_on_one_client(client, properties)


    class IsEnabled(Base):
        def run(self, clients, bus=None, mandos=None):
            client, properties = next(iter(clients.items()))
            if self.is_enabled(client, properties):
                sys.exit(0)
            sys.exit(1)
        def is_enabled(self, client, properties):
            return properties["Enabled"]


    class Approve(Base):
        def run_on_one_client(self, client, properties):
            log.debug("D-Bus: %s:%s:%s.Approve(True)", dbus_busname,
                      client.__dbus_object_path__,
                      client_dbus_interface)
            client.Approve(dbus.Boolean(True),
                           dbus_interface=client_dbus_interface)


    class Deny(Base):
        def run_on_one_client(self, client, properties):
            log.debug("D-Bus: %s:%s:%s.Approve(False)", dbus_busname,
                      client.__dbus_object_path__,
                      client_dbus_interface)
            client.Approve(dbus.Boolean(False),
                           dbus_interface=client_dbus_interface)


    class Remove(Base):
        def run_on_one_client(self, client, properties):
            log.debug("D-Bus: %s:%s:%s.RemoveClient(%r)",
                      dbus_busname, server_dbus_path,
                      server_dbus_interface,
                      str(client.__dbus_object_path__))
            self.mandos.RemoveClient(client.__dbus_object_path__)


    class Output(Base):
        """Abstract class for commands outputting client details"""
        all_keywords = ("Name", "Enabled", "Timeout", "LastCheckedOK",
                        "Created", "Interval", "Host", "KeyID",
                        "Fingerprint", "CheckerRunning",
                        "LastEnabled", "ApprovalPending",
                        "ApprovedByDefault", "LastApprovalRequest",
                        "ApprovalDelay", "ApprovalDuration",
                        "Checker", "ExtendedTimeout", "Expires",
                        "LastCheckerStatus")

        def run(self, clients, bus=None, mandos=None):
            print(self.output(clients.values()))

        def output(self, clients):
            raise NotImplementedError()


    class DumpJSON(Output):
        def output(self, clients):
            data = {client["Name"]:
                    {key: self.dbus_boolean_to_bool(client[key])
                     for key in self.all_keywords}
                    for client in clients}
            return json.dumps(data, indent=4, separators=(',', ': '))

        @staticmethod
        def dbus_boolean_to_bool(value):
            if isinstance(value, dbus.Boolean):
                value = bool(value)
            return value


    class PrintTable(Output):
        def __init__(self, verbose=False):
            self.verbose = verbose

        def output(self, clients):
            default_keywords = ("Name", "Enabled", "Timeout",
                                "LastCheckedOK")
            keywords = default_keywords
            if self.verbose:
                keywords = self.all_keywords
            return str(self.TableOfClients(clients, keywords))

        class TableOfClients(object):
            tableheaders = {
                "Name": "Name",
                "Enabled": "Enabled",
                "Timeout": "Timeout",
                "LastCheckedOK": "Last Successful Check",
                "LastApprovalRequest": "Last Approval Request",
                "Created": "Created",
                "Interval": "Interval",
                "Host": "Host",
                "Fingerprint": "Fingerprint",
                "KeyID": "Key ID",
                "CheckerRunning": "Check Is Running",
                "LastEnabled": "Last Enabled",
                "ApprovalPending": "Approval Is Pending",
                "ApprovedByDefault": "Approved By Default",
                "ApprovalDelay": "Approval Delay",
                "ApprovalDuration": "Approval Duration",
                "Checker": "Checker",
                "ExtendedTimeout": "Extended Timeout",
                "Expires": "Expires",
                "LastCheckerStatus": "Last Checker Status",
            }

            def __init__(self, clients, keywords):
                self.clients = clients
                self.keywords = keywords

            def __str__(self):
                return "\n".join(self.rows())

            if sys.version_info.major == 2:
                __unicode__ = __str__
                def __str__(self):
                    return str(self).encode(
                        locale.getpreferredencoding())

            def rows(self):
                format_string = self.row_formatting_string()
                rows = [self.header_line(format_string)]
                rows.extend(self.client_line(client, format_string)
                            for client in self.clients)
                return rows

            def row_formatting_string(self):
                "Format string used to format table rows"
                return " ".join("{{{key}:{width}}}".format(
                    width=max(len(self.tableheaders[key]),
                              *(len(self.string_from_client(client,
                                                            key))
                                for client in self.clients)),
                    key=key)
                                for key in self.keywords)

            def string_from_client(self, client, key):
                return self.valuetostring(client[key], key)

            @classmethod
            def valuetostring(cls, value, keyword):
                if isinstance(value, dbus.Boolean):
                    return "Yes" if value else "No"
                if keyword in ("Timeout", "Interval", "ApprovalDelay",
                               "ApprovalDuration", "ExtendedTimeout"):
                    return cls.milliseconds_to_string(value)
                return str(value)

            def header_line(self, format_string):
                return format_string.format(**self.tableheaders)

            def client_line(self, client, format_string):
                return format_string.format(
                    **{key: self.string_from_client(client, key)
                       for key in self.keywords})

            @staticmethod
            def milliseconds_to_string(ms):
                td = datetime.timedelta(0, 0, 0, ms)
                return ("{days}{hours:02}:{minutes:02}:{seconds:02}"
                        .format(days="{}T".format(td.days)
                                if td.days else "",
                                hours=td.seconds // 3600,
                                minutes=(td.seconds % 3600) // 60,
                                seconds=td.seconds % 60))


    class Property(Base):
        "Abstract class for Actions for setting one client property"

        def run_on_one_client(self, client, properties):
            """Set the Client's D-Bus property"""
            log.debug("D-Bus: %s:%s:%s.Set(%r, %r, %r)", dbus_busname,
                      client.__dbus_object_path__,
                      dbus.PROPERTIES_IFACE, client_dbus_interface,
                      self.propname, self.value_to_set
                      if not isinstance(self.value_to_set,
                                        dbus.Boolean)
                      else bool(self.value_to_set))
            client.Set(client_dbus_interface, self.propname,
                       self.value_to_set,
                       dbus_interface=dbus.PROPERTIES_IFACE)

        @property
        def propname(self):
            raise NotImplementedError()


    class Enable(Property):
        propname = "Enabled"
        value_to_set = dbus.Boolean(True)


    class Disable(Property):
        propname = "Enabled"
        value_to_set = dbus.Boolean(False)


    class BumpTimeout(Property):
        propname = "LastCheckedOK"
        value_to_set = ""


    class StartChecker(Property):
        propname = "CheckerRunning"
        value_to_set = dbus.Boolean(True)


    class StopChecker(Property):
        propname = "CheckerRunning"
        value_to_set = dbus.Boolean(False)


    class ApproveByDefault(Property):
        propname = "ApprovedByDefault"
        value_to_set = dbus.Boolean(True)


    class DenyByDefault(Property):
        propname = "ApprovedByDefault"
        value_to_set = dbus.Boolean(False)


    class PropertyValue(Property):
        "Abstract class for Property recieving a value as argument"
        def __init__(self, value):
            self.value_to_set = value


    class SetChecker(PropertyValue):
        propname = "Checker"


    class SetHost(PropertyValue):
        propname = "Host"


    class SetSecret(PropertyValue):
        propname = "Secret"

        @property
        def value_to_set(self):
            return self._vts

        @value_to_set.setter
        def value_to_set(self, value):
            """When setting, read data from supplied file object"""
            self._vts = value.read()
            value.close()


    class MillisecondsPropertyValueArgument(PropertyValue):
        """Abstract class for PropertyValue taking a value argument as
a datetime.timedelta() but should store it as milliseconds."""

        @property
        def value_to_set(self):
            return self._vts

        @value_to_set.setter
        def value_to_set(self, value):
            "When setting, convert value from a datetime.timedelta"
            self._vts = int(round(value.total_seconds() * 1000))


    class SetTimeout(MillisecondsPropertyValueArgument):
        propname = "Timeout"


    class SetExtendedTimeout(MillisecondsPropertyValueArgument):
        propname = "ExtendedTimeout"


    class SetInterval(MillisecondsPropertyValueArgument):
        propname = "Interval"


    class SetApprovalDelay(MillisecondsPropertyValueArgument):
        propname = "ApprovalDelay"


    class SetApprovalDuration(MillisecondsPropertyValueArgument):
        propname = "ApprovalDuration"



class TestCaseWithAssertLogs(unittest.TestCase):
    """unittest.TestCase.assertLogs only exists in Python 3.4"""

    if not hasattr(unittest.TestCase, "assertLogs"):
        @contextlib.contextmanager
        def assertLogs(self, logger, level=logging.INFO):
            capturing_handler = self.CapturingLevelHandler(level)
            old_level = logger.level
            old_propagate = logger.propagate
            logger.addHandler(capturing_handler)
            logger.setLevel(level)
            logger.propagate = False
            try:
                yield capturing_handler.watcher
            finally:
                logger.propagate = old_propagate
                logger.removeHandler(capturing_handler)
                logger.setLevel(old_level)
            self.assertGreater(len(capturing_handler.watcher.records),
                               0)

        class CapturingLevelHandler(logging.Handler):
            def __init__(self, level, *args, **kwargs):
                logging.Handler.__init__(self, *args, **kwargs)
                self.watcher = self.LoggingWatcher([], [])
            def emit(self, record):
                self.watcher.records.append(record)
                self.watcher.output.append(self.format(record))

            LoggingWatcher = collections.namedtuple("LoggingWatcher",
                                                    ("records",
                                                     "output"))


class Test_string_to_delta(TestCaseWithAssertLogs):
    def test_handles_basic_rfc3339(self):
        self.assertEqual(string_to_delta("PT0S"),
                         datetime.timedelta())
        self.assertEqual(string_to_delta("P0D"),
                         datetime.timedelta())
        self.assertEqual(string_to_delta("PT1S"),
                         datetime.timedelta(0, 1))
        self.assertEqual(string_to_delta("PT2H"),
                         datetime.timedelta(0, 7200))

    def test_falls_back_to_pre_1_6_1_with_warning(self):
        with self.assertLogs(log, logging.WARNING):
            value = string_to_delta("2h")
        self.assertEqual(value, datetime.timedelta(0, 7200))


class Test_check_option_syntax(unittest.TestCase):
    def setUp(self):
        self.parser = argparse.ArgumentParser()
        add_command_line_options(self.parser)

    def test_actions_requires_client_or_all(self):
        for action, value in self.actions.items():
            options = self.parser.parse_args()
            setattr(options, action, value)
            with self.assertParseError():
                self.check_option_syntax(options)

    # This mostly corresponds to the definition from has_actions() in
    # check_option_syntax()
    actions = {
        # The actual values set here are not that important, but we do
        # at least stick to the correct types, even though they are
        # never used
        "enable": True,
        "disable": True,
        "bump_timeout": True,
        "start_checker": True,
        "stop_checker": True,
        "is_enabled": True,
        "remove": True,
        "checker": "x",
        "timeout": datetime.timedelta(),
        "extended_timeout": datetime.timedelta(),
        "interval": datetime.timedelta(),
        "approved_by_default": True,
        "approval_delay": datetime.timedelta(),
        "approval_duration": datetime.timedelta(),
        "host": "x",
        "secret": io.BytesIO(b"x"),
        "approve": True,
        "deny": True,
    }

    @contextlib.contextmanager
    def assertParseError(self):
        with self.assertRaises(SystemExit) as e:
            with self.redirect_stderr_to_devnull():
                yield
        # Exit code from argparse is guaranteed to be "2".  Reference:
        # https://docs.python.org/3/library
        # /argparse.html#exiting-methods
        self.assertEqual(e.exception.code, 2)

    @staticmethod
    @contextlib.contextmanager
    def redirect_stderr_to_devnull():
        null = os.open(os.path.devnull, os.O_RDWR)
        stderrcopy = os.dup(sys.stderr.fileno())
        os.dup2(null, sys.stderr.fileno())
        os.close(null)
        try:
            yield
        finally:
            # restore stderr
            os.dup2(stderrcopy, sys.stderr.fileno())
            os.close(stderrcopy)

    def check_option_syntax(self, options):
        check_option_syntax(self.parser, options)

    def test_actions_all_conflicts_with_verbose(self):
        for action, value in self.actions.items():
            options = self.parser.parse_args()
            setattr(options, action, value)
            options.all = True
            options.verbose = True
            with self.assertParseError():
                self.check_option_syntax(options)

    def test_actions_with_client_conflicts_with_verbose(self):
        for action, value in self.actions.items():
            options = self.parser.parse_args()
            setattr(options, action, value)
            options.verbose = True
            options.client = ["foo"]
            with self.assertParseError():
                self.check_option_syntax(options)

    def test_dump_json_conflicts_with_verbose(self):
        options = self.parser.parse_args()
        options.dump_json = True
        options.verbose = True
        with self.assertParseError():
            self.check_option_syntax(options)

    def test_dump_json_conflicts_with_action(self):
        for action, value in self.actions.items():
            options = self.parser.parse_args()
            setattr(options, action, value)
            options.dump_json = True
            with self.assertParseError():
                self.check_option_syntax(options)

    def test_all_can_not_be_alone(self):
        options = self.parser.parse_args()
        options.all = True
        with self.assertParseError():
            self.check_option_syntax(options)

    def test_all_is_ok_with_any_action(self):
        for action, value in self.actions.items():
            options = self.parser.parse_args()
            setattr(options, action, value)
            options.all = True
            self.check_option_syntax(options)

    def test_any_action_is_ok_with_one_client(self):
        for action, value in self.actions.items():
            options = self.parser.parse_args()
            setattr(options, action, value)
            options.client = ["foo"]
            self.check_option_syntax(options)

    def test_one_client_with_all_actions_except_is_enabled(self):
        options = self.parser.parse_args()
        for action, value in self.actions.items():
            if action == "is_enabled":
                continue
            setattr(options, action, value)
        options.client = ["foo"]
        self.check_option_syntax(options)

    def test_two_clients_with_all_actions_except_is_enabled(self):
        options = self.parser.parse_args()
        for action, value in self.actions.items():
            if action == "is_enabled":
                continue
            setattr(options, action, value)
        options.client = ["foo", "barbar"]
        self.check_option_syntax(options)

    def test_two_clients_are_ok_with_actions_except_is_enabled(self):
        for action, value in self.actions.items():
            if action == "is_enabled":
                continue
            options = self.parser.parse_args()
            setattr(options, action, value)
            options.client = ["foo", "barbar"]
            self.check_option_syntax(options)

    def test_is_enabled_fails_without_client(self):
        options = self.parser.parse_args()
        options.is_enabled = True
        with self.assertParseError():
            self.check_option_syntax(options)

    def test_is_enabled_fails_with_two_clients(self):
        options = self.parser.parse_args()
        options.is_enabled = True
        options.client = ["foo", "barbar"]
        with self.assertParseError():
            self.check_option_syntax(options)

    def test_remove_can_only_be_combined_with_action_deny(self):
        for action, value in self.actions.items():
            if action in {"remove", "deny"}:
                continue
            options = self.parser.parse_args()
            setattr(options, action, value)
            options.all = True
            options.remove = True
            with self.assertParseError():
                self.check_option_syntax(options)


class Test_get_mandos_dbus_object(TestCaseWithAssertLogs):
    def test_calls_and_returns_get_object_on_bus(self):
        class MockBus(object):
            called = False
            def get_object(mockbus_self, busname, dbus_path):
                # Note that "self" is still the testcase instance,
                # this MockBus instance is in "mockbus_self".
                self.assertEqual(busname, dbus_busname)
                self.assertEqual(dbus_path, server_dbus_path)
                mockbus_self.called = True
                return mockbus_self

        mockbus = get_mandos_dbus_object(bus=MockBus())
        self.assertIsInstance(mockbus, MockBus)
        self.assertTrue(mockbus.called)

    def test_logs_and_exits_on_dbus_error(self):
        class MockBusFailing(object):
            def get_object(self, busname, dbus_path):
                raise dbus.exceptions.DBusException("Test")

        with self.assertLogs(log, logging.CRITICAL):
            with self.assertRaises(SystemExit) as e:
                bus = get_mandos_dbus_object(bus=MockBusFailing())

        if isinstance(e.exception.code, int):
            self.assertNotEqual(e.exception.code, 0)
        else:
            self.assertIsNotNone(e.exception.code)


class Test_get_managed_objects(TestCaseWithAssertLogs):
    def test_calls_and_returns_GetManagedObjects(self):
        managed_objects = {"/clients/foo": { "Name": "foo"}}
        class MockObjectManager(object):
            def GetManagedObjects(self):
                return managed_objects
        retval = get_managed_objects(MockObjectManager())
        self.assertDictEqual(managed_objects, retval)

    def test_logs_and_exits_on_dbus_error(self):
        dbus_logger = logging.getLogger("dbus.proxies")

        class MockObjectManagerFailing(object):
            def GetManagedObjects(self):
                dbus_logger.error("Test")
                raise dbus.exceptions.DBusException("Test")

        class CountingHandler(logging.Handler):
            count = 0
            def emit(self, record):
                self.count += 1

        counting_handler = CountingHandler()

        dbus_logger.addHandler(counting_handler)

        try:
            with self.assertLogs(log, logging.CRITICAL) as watcher:
                with self.assertRaises(SystemExit) as e:
                    get_managed_objects(MockObjectManagerFailing())
        finally:
            dbus_logger.removeFilter(counting_handler)

        # Make sure the dbus logger was suppressed
        self.assertEqual(counting_handler.count, 0)

        # Test that the dbus_logger still works
        with self.assertLogs(dbus_logger, logging.ERROR):
            dbus_logger.error("Test")

        if isinstance(e.exception.code, int):
            self.assertNotEqual(e.exception.code, 0)
        else:
            self.assertIsNotNone(e.exception.code)


class Test_commands_from_options(unittest.TestCase):
    def setUp(self):
        self.parser = argparse.ArgumentParser()
        add_command_line_options(self.parser)

    def test_is_enabled(self):
        self.assert_command_from_args(["--is-enabled", "foo"],
                                      command.IsEnabled)

    def assert_command_from_args(self, args, command_cls,
                                 **cmd_attrs):
        """Assert that parsing ARGS should result in an instance of
COMMAND_CLS with (optionally) all supplied attributes (CMD_ATTRS)."""
        options = self.parser.parse_args(args)
        check_option_syntax(self.parser, options)
        commands = commands_from_options(options)
        self.assertEqual(len(commands), 1)
        command = commands[0]
        self.assertIsInstance(command, command_cls)
        for key, value in cmd_attrs.items():
            self.assertEqual(getattr(command, key), value)

    def test_is_enabled_short(self):
        self.assert_command_from_args(["-V", "foo"],
                                      command.IsEnabled)

    def test_approve(self):
        self.assert_command_from_args(["--approve", "foo"],
                                      command.Approve)

    def test_approve_short(self):
        self.assert_command_from_args(["-A", "foo"], command.Approve)

    def test_deny(self):
        self.assert_command_from_args(["--deny", "foo"], command.Deny)

    def test_deny_short(self):
        self.assert_command_from_args(["-D", "foo"], command.Deny)

    def test_remove(self):
        self.assert_command_from_args(["--remove", "foo"],
                                      command.Remove)

    def test_deny_before_remove(self):
        options = self.parser.parse_args(["--deny", "--remove",
                                          "foo"])
        check_option_syntax(self.parser, options)
        commands = commands_from_options(options)
        self.assertEqual(len(commands), 2)
        self.assertIsInstance(commands[0], command.Deny)
        self.assertIsInstance(commands[1], command.Remove)

    def test_deny_before_remove_reversed(self):
        options = self.parser.parse_args(["--remove", "--deny",
                                          "--all"])
        check_option_syntax(self.parser, options)
        commands = commands_from_options(options)
        self.assertEqual(len(commands), 2)
        self.assertIsInstance(commands[0], command.Deny)
        self.assertIsInstance(commands[1], command.Remove)

    def test_remove_short(self):
        self.assert_command_from_args(["-r", "foo"], command.Remove)

    def test_dump_json(self):
        self.assert_command_from_args(["--dump-json"],
                                      command.DumpJSON)

    def test_enable(self):
        self.assert_command_from_args(["--enable", "foo"],
                                      command.Enable)

    def test_enable_short(self):
        self.assert_command_from_args(["-e", "foo"], command.Enable)

    def test_disable(self):
        self.assert_command_from_args(["--disable", "foo"],
                                      command.Disable)

    def test_disable_short(self):
        self.assert_command_from_args(["-d", "foo"], command.Disable)

    def test_bump_timeout(self):
        self.assert_command_from_args(["--bump-timeout", "foo"],
                                      command.BumpTimeout)

    def test_bump_timeout_short(self):
        self.assert_command_from_args(["-b", "foo"],
                                      command.BumpTimeout)

    def test_start_checker(self):
        self.assert_command_from_args(["--start-checker", "foo"],
                                      command.StartChecker)

    def test_stop_checker(self):
        self.assert_command_from_args(["--stop-checker", "foo"],
                                      command.StopChecker)

    def test_approve_by_default(self):
        self.assert_command_from_args(["--approve-by-default", "foo"],
                                      command.ApproveByDefault)

    def test_deny_by_default(self):
        self.assert_command_from_args(["--deny-by-default", "foo"],
                                      command.DenyByDefault)

    def test_checker(self):
        self.assert_command_from_args(["--checker", ":", "foo"],
                                      command.SetChecker,
                                      value_to_set=":")

    def test_checker_empty(self):
        self.assert_command_from_args(["--checker", "", "foo"],
                                      command.SetChecker,
                                      value_to_set="")

    def test_checker_short(self):
        self.assert_command_from_args(["-c", ":", "foo"],
                                      command.SetChecker,
                                      value_to_set=":")

    def test_host(self):
        self.assert_command_from_args(["--host", "foo.example.org",
                                       "foo"], command.SetHost,
                                      value_to_set="foo.example.org")

    def test_host_short(self):
        self.assert_command_from_args(["-H", "foo.example.org",
                                       "foo"], command.SetHost,
                                      value_to_set="foo.example.org")

    def test_secret_devnull(self):
        self.assert_command_from_args(["--secret", os.path.devnull,
                                       "foo"], command.SetSecret,
                                      value_to_set=b"")

    def test_secret_tempfile(self):
        with tempfile.NamedTemporaryFile(mode="r+b") as f:
            value = b"secret\0xyzzy\nbar"
            f.write(value)
            f.seek(0)
            self.assert_command_from_args(["--secret", f.name,
                                           "foo"], command.SetSecret,
                                          value_to_set=value)

    def test_secret_devnull_short(self):
        self.assert_command_from_args(["-s", os.path.devnull, "foo"],
                                      command.SetSecret,
                                      value_to_set=b"")

    def test_secret_tempfile_short(self):
        with tempfile.NamedTemporaryFile(mode="r+b") as f:
            value = b"secret\0xyzzy\nbar"
            f.write(value)
            f.seek(0)
            self.assert_command_from_args(["-s", f.name, "foo"],
                                          command.SetSecret,
                                          value_to_set=value)

    def test_timeout(self):
        self.assert_command_from_args(["--timeout", "PT5M", "foo"],
                                      command.SetTimeout,
                                      value_to_set=300000)

    def test_timeout_short(self):
        self.assert_command_from_args(["-t", "PT5M", "foo"],
                                      command.SetTimeout,
                                      value_to_set=300000)

    def test_extended_timeout(self):
        self.assert_command_from_args(["--extended-timeout", "PT15M",
                                       "foo"],
                                      command.SetExtendedTimeout,
                                      value_to_set=900000)

    def test_interval(self):
        self.assert_command_from_args(["--interval", "PT2M", "foo"],
                                      command.SetInterval,
                                      value_to_set=120000)

    def test_interval_short(self):
        self.assert_command_from_args(["-i", "PT2M", "foo"],
                                      command.SetInterval,
                                      value_to_set=120000)

    def test_approval_delay(self):
        self.assert_command_from_args(["--approval-delay", "PT30S",
                                       "foo"],
                                      command.SetApprovalDelay,
                                      value_to_set=30000)

    def test_approval_duration(self):
        self.assert_command_from_args(["--approval-duration", "PT1S",
                                       "foo"],
                                      command.SetApprovalDuration,
                                      value_to_set=1000)

    def test_print_table(self):
        self.assert_command_from_args([], command.PrintTable,
                                      verbose=False)

    def test_print_table_verbose(self):
        self.assert_command_from_args(["--verbose"],
                                      command.PrintTable,
                                      verbose=True)

    def test_print_table_verbose_short(self):
        self.assert_command_from_args(["-v"], command.PrintTable,
                                      verbose=True)


class TestCommand(unittest.TestCase):
    """Abstract class for tests of command classes"""

    def setUp(self):
        testcase = self
        class MockClient(object):
            def __init__(self, name, **attributes):
                self.__dbus_object_path__ = "/clients/{}".format(name)
                self.attributes = attributes
                self.attributes["Name"] = name
                self.calls = []
            def Set(self, interface, propname, value, dbus_interface):
                testcase.assertEqual(interface, client_dbus_interface)
                testcase.assertEqual(dbus_interface,
                                     dbus.PROPERTIES_IFACE)
                self.attributes[propname] = value
            def Get(self, interface, propname, dbus_interface):
                testcase.assertEqual(interface, client_dbus_interface)
                testcase.assertEqual(dbus_interface,
                                     dbus.PROPERTIES_IFACE)
                return self.attributes[propname]
            def Approve(self, approve, dbus_interface):
                testcase.assertEqual(dbus_interface,
                                     client_dbus_interface)
                self.calls.append(("Approve", (approve,
                                               dbus_interface)))
        self.client = MockClient(
            "foo",
            KeyID=("92ed150794387c03ce684574b1139a65"
                   "94a34f895daaaf09fd8ea90a27cddb12"),
            Secret=b"secret",
            Host="foo.example.org",
            Enabled=dbus.Boolean(True),
            Timeout=300000,
            LastCheckedOK="2019-02-03T00:00:00",
            Created="2019-01-02T00:00:00",
            Interval=120000,
            Fingerprint=("778827225BA7DE539C5A"
                         "7CFA59CFF7CDBD9A5920"),
            CheckerRunning=dbus.Boolean(False),
            LastEnabled="2019-01-03T00:00:00",
            ApprovalPending=dbus.Boolean(False),
            ApprovedByDefault=dbus.Boolean(True),
            LastApprovalRequest="",
            ApprovalDelay=0,
            ApprovalDuration=1000,
            Checker="fping -q -- %(host)s",
            ExtendedTimeout=900000,
            Expires="2019-02-04T00:00:00",
            LastCheckerStatus=0)
        self.other_client = MockClient(
            "barbar",
            KeyID=("0558568eedd67d622f5c83b35a115f79"
                   "6ab612cff5ad227247e46c2b020f441c"),
            Secret=b"secretbar",
            Host="192.0.2.3",
            Enabled=dbus.Boolean(True),
            Timeout=300000,
            LastCheckedOK="2019-02-04T00:00:00",
            Created="2019-01-03T00:00:00",
            Interval=120000,
            Fingerprint=("3E393AEAEFB84C7E89E2"
                         "F547B3A107558FCA3A27"),
            CheckerRunning=dbus.Boolean(True),
            LastEnabled="2019-01-04T00:00:00",
            ApprovalPending=dbus.Boolean(False),
            ApprovedByDefault=dbus.Boolean(False),
            LastApprovalRequest="2019-01-03T00:00:00",
            ApprovalDelay=30000,
            ApprovalDuration=93785000,
            Checker=":",
            ExtendedTimeout=900000,
            Expires="2019-02-05T00:00:00",
            LastCheckerStatus=-2)
        self.clients =  collections.OrderedDict(
            [
                ("/clients/foo", self.client.attributes),
                ("/clients/barbar", self.other_client.attributes),
            ])
        self.one_client = {"/clients/foo": self.client.attributes}

    @property
    def bus(self):
        class Bus(object):
            @staticmethod
            def get_object(client_bus_name, path):
                self.assertEqual(client_bus_name, dbus_busname)
                return {
                    # Note: "self" here is the TestCmd instance, not
                    # the Bus instance, since this is a static method!
                    "/clients/foo": self.client,
                    "/clients/barbar": self.other_client,
                }[path]
        return Bus()


class TestBaseCommands(TestCommand):

    def test_is_enabled(self):
        self.assertTrue(all(command.IsEnabled().is_enabled(client,
                                                      properties)
                            for client, properties
                            in self.clients.items()))

    def test_is_enabled_run_exits_successfully(self):
        with self.assertRaises(SystemExit) as e:
            command.IsEnabled().run(self.one_client)
        if e.exception.code is not None:
            self.assertEqual(e.exception.code, 0)
        else:
            self.assertIsNone(e.exception.code)

    def test_is_enabled_run_exits_with_failure(self):
        self.client.attributes["Enabled"] = dbus.Boolean(False)
        with self.assertRaises(SystemExit) as e:
            command.IsEnabled().run(self.one_client)
        if isinstance(e.exception.code, int):
            self.assertNotEqual(e.exception.code, 0)
        else:
            self.assertIsNotNone(e.exception.code)

    def test_approve(self):
        command.Approve().run(self.clients, self.bus)
        for clientpath in self.clients:
            client = self.bus.get_object(dbus_busname, clientpath)
            self.assertIn(("Approve", (True, client_dbus_interface)),
                          client.calls)

    def test_deny(self):
        command.Deny().run(self.clients, self.bus)
        for clientpath in self.clients:
            client = self.bus.get_object(dbus_busname, clientpath)
            self.assertIn(("Approve", (False, client_dbus_interface)),
                          client.calls)

    def test_remove(self):
        class MockMandos(object):
            def __init__(self):
                self.calls = []
            def RemoveClient(self, dbus_path):
                self.calls.append(("RemoveClient", (dbus_path,)))
        mandos = MockMandos()
        super(TestBaseCommands, self).setUp()
        command.Remove().run(self.clients, self.bus, mandos)
        self.assertEqual(len(mandos.calls), 2)
        for clientpath in self.clients:
            self.assertIn(("RemoveClient", (clientpath,)),
                          mandos.calls)

    expected_json = {
        "foo": {
            "Name": "foo",
            "KeyID": ("92ed150794387c03ce684574b1139a65"
                      "94a34f895daaaf09fd8ea90a27cddb12"),
            "Host": "foo.example.org",
            "Enabled": True,
            "Timeout": 300000,
            "LastCheckedOK": "2019-02-03T00:00:00",
            "Created": "2019-01-02T00:00:00",
            "Interval": 120000,
            "Fingerprint": ("778827225BA7DE539C5A"
                            "7CFA59CFF7CDBD9A5920"),
            "CheckerRunning": False,
            "LastEnabled": "2019-01-03T00:00:00",
            "ApprovalPending": False,
            "ApprovedByDefault": True,
            "LastApprovalRequest": "",
            "ApprovalDelay": 0,
            "ApprovalDuration": 1000,
            "Checker": "fping -q -- %(host)s",
            "ExtendedTimeout": 900000,
            "Expires": "2019-02-04T00:00:00",
            "LastCheckerStatus": 0,
        },
        "barbar": {
            "Name": "barbar",
            "KeyID": ("0558568eedd67d622f5c83b35a115f79"
                      "6ab612cff5ad227247e46c2b020f441c"),
            "Host": "192.0.2.3",
            "Enabled": True,
            "Timeout": 300000,
            "LastCheckedOK": "2019-02-04T00:00:00",
            "Created": "2019-01-03T00:00:00",
            "Interval": 120000,
            "Fingerprint": ("3E393AEAEFB84C7E89E2"
                            "F547B3A107558FCA3A27"),
            "CheckerRunning": True,
            "LastEnabled": "2019-01-04T00:00:00",
            "ApprovalPending": False,
            "ApprovedByDefault": False,
            "LastApprovalRequest": "2019-01-03T00:00:00",
            "ApprovalDelay": 30000,
            "ApprovalDuration": 93785000,
            "Checker": ":",
            "ExtendedTimeout": 900000,
            "Expires": "2019-02-05T00:00:00",
            "LastCheckerStatus": -2,
        },
    }

    def test_DumpJSON_normal(self):
        output = command.DumpJSON().output(self.clients.values())
        json_data = json.loads(output)
        self.assertDictEqual(json_data, self.expected_json)

    def test_DumpJSON_one_client(self):
        output = command.DumpJSON().output(self.one_client.values())
        json_data = json.loads(output)
        expected_json = {"foo": self.expected_json["foo"]}
        self.assertDictEqual(json_data, expected_json)

    def test_PrintTable_normal(self):
        output = command.PrintTable().output(self.clients.values())
        expected_output = "\n".join((
            "Name   Enabled Timeout  Last Successful Check",
            "foo    Yes     00:05:00 2019-02-03T00:00:00  ",
            "barbar Yes     00:05:00 2019-02-04T00:00:00  ",
        ))
        self.assertEqual(output, expected_output)

    def test_PrintTable_verbose(self):
        output = command.PrintTable(verbose=True).output(
            self.clients.values())
        columns = (
            (
                "Name   ",
                "foo    ",
                "barbar ",
            ),(
                "Enabled ",
                "Yes     ",
                "Yes     ",
            ),(
                "Timeout  ",
                "00:05:00 ",
                "00:05:00 ",
            ),(
                "Last Successful Check ",
                "2019-02-03T00:00:00   ",
                "2019-02-04T00:00:00   ",
            ),(
                "Created             ",
                "2019-01-02T00:00:00 ",
                "2019-01-03T00:00:00 ",
            ),(
                "Interval ",
                "00:02:00 ",
                "00:02:00 ",
            ),(
                "Host            ",
                "foo.example.org ",
                "192.0.2.3       ",
            ),(
                ("Key ID                                             "
                 "              "),
                ("92ed150794387c03ce684574b1139a6594a34f895daaaf09fd8"
                 "ea90a27cddb12 "),
                ("0558568eedd67d622f5c83b35a115f796ab612cff5ad227247e"
                 "46c2b020f441c "),
            ),(
                "Fingerprint                              ",
                "778827225BA7DE539C5A7CFA59CFF7CDBD9A5920 ",
                "3E393AEAEFB84C7E89E2F547B3A107558FCA3A27 ",
            ),(
                "Check Is Running ",
                "No               ",
                "Yes              ",
            ),(
                "Last Enabled        ",
                "2019-01-03T00:00:00 ",
                "2019-01-04T00:00:00 ",
            ),(
                "Approval Is Pending ",
                "No                  ",
                "No                  ",
            ),(
                "Approved By Default ",
                "Yes                 ",
                "No                  ",
            ),(
                "Last Approval Request ",
                "                      ",
                "2019-01-03T00:00:00   ",
            ),(
                "Approval Delay ",
                "00:00:00       ",
                "00:00:30       ",
            ),(
                "Approval Duration ",
                "00:00:01          ",
                "1T02:03:05        ",
            ),(
                "Checker              ",
                "fping -q -- %(host)s ",
                ":                    ",
            ),(
                "Extended Timeout ",
                "00:15:00         ",
                "00:15:00         ",
            ),(
                "Expires             ",
                "2019-02-04T00:00:00 ",
                "2019-02-05T00:00:00 ",
            ),(
                "Last Checker Status",
                "0                  ",
                "-2                 ",
            )
        )
        num_lines = max(len(rows) for rows in columns)
        expected_output = "\n".join("".join(rows[line]
                                            for rows in columns)
                                    for line in range(num_lines))
        self.assertEqual(output, expected_output)

    def test_PrintTable_one_client(self):
        output = command.PrintTable().output(self.one_client.values())
        expected_output = "\n".join((
            "Name Enabled Timeout  Last Successful Check",
            "foo  Yes     00:05:00 2019-02-03T00:00:00  ",
        ))
        self.assertEqual(output, expected_output)


class TestPropertyCmd(TestCommand):
    """Abstract class for tests of command.Property classes"""
    def runTest(self):
        if not hasattr(self, "command"):
            return
        values_to_get = getattr(self, "values_to_get",
                                self.values_to_set)
        for value_to_set, value_to_get in zip(self.values_to_set,
                                              values_to_get):
            for clientpath in self.clients:
                client = self.bus.get_object(dbus_busname, clientpath)
                old_value = client.attributes[self.propname]
                self.assertNotIsInstance(old_value, self.Unique)
                client.attributes[self.propname] = self.Unique()
            self.run_command(value_to_set, self.clients)
            for clientpath in self.clients:
                client = self.bus.get_object(dbus_busname, clientpath)
                value = client.attributes[self.propname]
                self.assertNotIsInstance(value, self.Unique)
                self.assertEqual(value, value_to_get)

    class Unique(object):
        """Class for objects which exist only to be unique objects,
since unittest.mock.sentinel only exists in Python 3.3"""

    def run_command(self, value, clients):
        self.command().run(clients, self.bus)


class TestEnableCmd(TestPropertyCmd):
    command = command.Enable
    propname = "Enabled"
    values_to_set = [dbus.Boolean(True)]


class TestDisableCmd(TestPropertyCmd):
    command = command.Disable
    propname = "Enabled"
    values_to_set = [dbus.Boolean(False)]


class TestBumpTimeoutCmd(TestPropertyCmd):
    command = command.BumpTimeout
    propname = "LastCheckedOK"
    values_to_set = [""]


class TestStartCheckerCmd(TestPropertyCmd):
    command = command.StartChecker
    propname = "CheckerRunning"
    values_to_set = [dbus.Boolean(True)]


class TestStopCheckerCmd(TestPropertyCmd):
    command = command.StopChecker
    propname = "CheckerRunning"
    values_to_set = [dbus.Boolean(False)]


class TestApproveByDefaultCmd(TestPropertyCmd):
    command = command.ApproveByDefault
    propname = "ApprovedByDefault"
    values_to_set = [dbus.Boolean(True)]


class TestDenyByDefaultCmd(TestPropertyCmd):
    command = command.DenyByDefault
    propname = "ApprovedByDefault"
    values_to_set = [dbus.Boolean(False)]


class TestPropertyValueCmd(TestPropertyCmd):
    """Abstract class for tests of PropertyValueCmd classes"""

    def runTest(self):
        if type(self) is TestPropertyValueCmd:
            return
        return super(TestPropertyValueCmd, self).runTest()

    def run_command(self, value, clients):
        self.command(value).run(clients, self.bus)


class TestSetCheckerCmd(TestPropertyValueCmd):
    command = command.SetChecker
    propname = "Checker"
    values_to_set = ["", ":", "fping -q -- %s"]


class TestSetHostCmd(TestPropertyValueCmd):
    command = command.SetHost
    propname = "Host"
    values_to_set = ["192.0.2.3", "foo.example.org"]


class TestSetSecretCmd(TestPropertyValueCmd):
    command = command.SetSecret
    propname = "Secret"
    values_to_set = [io.BytesIO(b""),
                     io.BytesIO(b"secret\0xyzzy\nbar")]
    values_to_get = [b"", b"secret\0xyzzy\nbar"]


class TestSetTimeoutCmd(TestPropertyValueCmd):
    command = command.SetTimeout
    propname = "Timeout"
    values_to_set = [datetime.timedelta(),
                     datetime.timedelta(minutes=5),
                     datetime.timedelta(seconds=1),
                     datetime.timedelta(weeks=1),
                     datetime.timedelta(weeks=52)]
    values_to_get = [0, 300000, 1000, 604800000, 31449600000]


class TestSetExtendedTimeoutCmd(TestPropertyValueCmd):
    command = command.SetExtendedTimeout
    propname = "ExtendedTimeout"
    values_to_set = [datetime.timedelta(),
                     datetime.timedelta(minutes=5),
                     datetime.timedelta(seconds=1),
                     datetime.timedelta(weeks=1),
                     datetime.timedelta(weeks=52)]
    values_to_get = [0, 300000, 1000, 604800000, 31449600000]


class TestSetIntervalCmd(TestPropertyValueCmd):
    command = command.SetInterval
    propname = "Interval"
    values_to_set = [datetime.timedelta(),
                     datetime.timedelta(minutes=5),
                     datetime.timedelta(seconds=1),
                     datetime.timedelta(weeks=1),
                     datetime.timedelta(weeks=52)]
    values_to_get = [0, 300000, 1000, 604800000, 31449600000]


class TestSetApprovalDelayCmd(TestPropertyValueCmd):
    command = command.SetApprovalDelay
    propname = "ApprovalDelay"
    values_to_set = [datetime.timedelta(),
                     datetime.timedelta(minutes=5),
                     datetime.timedelta(seconds=1),
                     datetime.timedelta(weeks=1),
                     datetime.timedelta(weeks=52)]
    values_to_get = [0, 300000, 1000, 604800000, 31449600000]


class TestSetApprovalDurationCmd(TestPropertyValueCmd):
    command = command.SetApprovalDuration
    propname = "ApprovalDuration"
    values_to_set = [datetime.timedelta(),
                     datetime.timedelta(minutes=5),
                     datetime.timedelta(seconds=1),
                     datetime.timedelta(weeks=1),
                     datetime.timedelta(weeks=52)]
    values_to_get = [0, 300000, 1000, 604800000, 31449600000]



def should_only_run_tests():
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument("--check", action='store_true')
    args, unknown_args = parser.parse_known_args()
    run_tests = args.check
    if run_tests:
        # Remove --check argument from sys.argv
        sys.argv[1:] = unknown_args
    return run_tests

# Add all tests from doctest strings
def load_tests(loader, tests, none):
    import doctest
    tests.addTests(doctest.DocTestSuite())
    return tests

if __name__ == "__main__":
    try:
        if should_only_run_tests():
            # Call using ./tdd-python-script --check [--verbose]
            unittest.main()
        else:
            main()
    finally:
        logging.shutdown()
