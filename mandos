#!/usr/bin/python
# -*- mode: python; coding: utf-8 -*-
# 
# Mandos server - give out binary blobs to connecting clients.
# 
# This program is partly derived from an example program for an Avahi
# service publisher, downloaded from
# <http://avahi.org/wiki/PythonPublishExample>.  This includes the
# methods "add", "remove", "server_state_changed",
# "entry_group_state_changed", "cleanup", and "activate" in the
# "AvahiService" class, and some lines in "main".
# 
# Everything else is
# Copyright © 2008-2012 Teddy Hogeborn
# Copyright © 2008-2012 Björn Påhlsson
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see
# <http://www.gnu.org/licenses/>.
# 
# Contact the authors at <mandos@recompile.se>.
# 

from __future__ import (division, absolute_import, print_function,
                        unicode_literals)

import SocketServer as socketserver
import socket
import argparse
import datetime
import errno
import gnutls.crypto
import gnutls.connection
import gnutls.errors
import gnutls.library.functions
import gnutls.library.constants
import gnutls.library.types
import ConfigParser as configparser
import sys
import re
import os
import signal
import subprocess
import atexit
import stat
import logging
import logging.handlers
import pwd
import contextlib
import struct
import fcntl
import functools
import cPickle as pickle
import multiprocessing
import types
import binascii
import tempfile
import itertools

import dbus
import dbus.service
import gobject
import avahi
from dbus.mainloop.glib import DBusGMainLoop
import ctypes
import ctypes.util
import xml.dom.minidom
import inspect
import GnuPGInterface

try:
    SO_BINDTODEVICE = socket.SO_BINDTODEVICE
except AttributeError:
    try:
        from IN import SO_BINDTODEVICE
    except ImportError:
        SO_BINDTODEVICE = None

version = "1.5.3"
stored_state_file = "clients.pickle"

logger = logging.getLogger()
syslogger = (logging.handlers.SysLogHandler
             (facility = logging.handlers.SysLogHandler.LOG_DAEMON,
              address = str("/dev/log")))

try:
    if_nametoindex = (ctypes.cdll.LoadLibrary
                      (ctypes.util.find_library("c"))
                      .if_nametoindex)
except (OSError, AttributeError):
    def if_nametoindex(interface):
        "Get an interface index the hard way, i.e. using fcntl()"
        SIOCGIFINDEX = 0x8933  # From /usr/include/linux/sockios.h
        with contextlib.closing(socket.socket()) as s:
            ifreq = fcntl.ioctl(s, SIOCGIFINDEX,
                                struct.pack(str("16s16x"),
                                            interface))
        interface_index = struct.unpack(str("I"),
                                        ifreq[16:20])[0]
        return interface_index


def initlogger(debug, level=logging.WARNING):
    """init logger and add loglevel"""
    
    syslogger.setFormatter(logging.Formatter
                           ('Mandos [%(process)d]: %(levelname)s:'
                            ' %(message)s'))
    logger.addHandler(syslogger)
    
    if debug:
        console = logging.StreamHandler()
        console.setFormatter(logging.Formatter('%(asctime)s %(name)s'
                                               ' [%(process)d]:'
                                               ' %(levelname)s:'
                                               ' %(message)s'))
        logger.addHandler(console)
    logger.setLevel(level)


class PGPError(Exception):
    """Exception if encryption/decryption fails"""
    pass


class PGPEngine(object):
    """A simple class for OpenPGP symmetric encryption & decryption"""
    def __init__(self):
        self.gnupg = GnuPGInterface.GnuPG()
        self.tempdir = tempfile.mkdtemp(prefix="mandos-")
        self.gnupg = GnuPGInterface.GnuPG()
        self.gnupg.options.meta_interactive = False
        self.gnupg.options.homedir = self.tempdir
        self.gnupg.options.extra_args.extend(['--force-mdc',
                                              '--quiet',
                                              '--no-use-agent'])
    
    def __enter__(self):
        return self
    
    def __exit__ (self, exc_type, exc_value, traceback):
        self._cleanup()
        return False
    
    def __del__(self):
        self._cleanup()
    
    def _cleanup(self):
        if self.tempdir is not None:
            # Delete contents of tempdir
            for root, dirs, files in os.walk(self.tempdir,
                                             topdown = False):
                for filename in files:
                    os.remove(os.path.join(root, filename))
                for dirname in dirs:
                    os.rmdir(os.path.join(root, dirname))
            # Remove tempdir
            os.rmdir(self.tempdir)
            self.tempdir = None
    
    def password_encode(self, password):
        # Passphrase can not be empty and can not contain newlines or
        # NUL bytes.  So we prefix it and hex encode it.
        return b"mandos" + binascii.hexlify(password)
    
    def encrypt(self, data, password):
        self.gnupg.passphrase = self.password_encode(password)
        with open(os.devnull, "w") as devnull:
            try:
                proc = self.gnupg.run(['--symmetric'],
                                      create_fhs=['stdin', 'stdout'],
                                      attach_fhs={'stderr': devnull})
                with contextlib.closing(proc.handles['stdin']) as f:
                    f.write(data)
                with contextlib.closing(proc.handles['stdout']) as f:
                    ciphertext = f.read()
                proc.wait()
            except IOError as e:
                raise PGPError(e)
        self.gnupg.passphrase = None
        return ciphertext
    
    def decrypt(self, data, password):
        self.gnupg.passphrase = self.password_encode(password)
        with open(os.devnull, "w") as devnull:
            try:
                proc = self.gnupg.run(['--decrypt'],
                                      create_fhs=['stdin', 'stdout'],
                                      attach_fhs={'stderr': devnull})
                with contextlib.closing(proc.handles['stdin']) as f:
                    f.write(data)
                with contextlib.closing(proc.handles['stdout']) as f:
                    decrypted_plaintext = f.read()
                proc.wait()
            except IOError as e:
                raise PGPError(e)
        self.gnupg.passphrase = None
        return decrypted_plaintext



class AvahiError(Exception):
    def __init__(self, value, *args, **kwargs):
        self.value = value
        super(AvahiError, self).__init__(value, *args, **kwargs)
    def __unicode__(self):
        return unicode(repr(self.value))

class AvahiServiceError(AvahiError):
    pass

class AvahiGroupError(AvahiError):
    pass


class AvahiService(object):
    """An Avahi (Zeroconf) service.
    
    Attributes:
    interface: integer; avahi.IF_UNSPEC or an interface index.
               Used to optionally bind to the specified interface.
    name: string; Example: 'Mandos'
    type: string; Example: '_mandos._tcp'.
                  See <http://www.dns-sd.org/ServiceTypes.html>
    port: integer; what port to announce
    TXT: list of strings; TXT record for the service
    domain: string; Domain to publish on, default to .local if empty.
    host: string; Host to publish records for, default is localhost
    max_renames: integer; maximum number of renames
    rename_count: integer; counter so we only rename after collisions
                  a sensible number of times
    group: D-Bus Entry Group
    server: D-Bus Server
    bus: dbus.SystemBus()
    """
    def __init__(self, interface = avahi.IF_UNSPEC, name = None,
                 servicetype = None, port = None, TXT = None,
                 domain = "", host = "", max_renames = 32768,
                 protocol = avahi.PROTO_UNSPEC, bus = None):
        self.interface = interface
        self.name = name
        self.type = servicetype
        self.port = port
        self.TXT = TXT if TXT is not None else []
        self.domain = domain
        self.host = host
        self.rename_count = 0
        self.max_renames = max_renames
        self.protocol = protocol
        self.group = None       # our entry group
        self.server = None
        self.bus = bus
        self.entry_group_state_changed_match = None
    def rename(self):
        """Derived from the Avahi example code"""
        if self.rename_count >= self.max_renames:
            logger.critical("No suitable Zeroconf service name found"
                            " after %i retries, exiting.",
                            self.rename_count)
            raise AvahiServiceError("Too many renames")
        self.name = unicode(self.server
                            .GetAlternativeServiceName(self.name))
        logger.info("Changing Zeroconf service name to %r ...",
                    self.name)
        self.remove()
        try:
            self.add()
        except dbus.exceptions.DBusException as error:
            logger.critical("D-Bus Exception", exc_info=error)
            self.cleanup()
            os._exit(1)
        self.rename_count += 1
    def remove(self):
        """Derived from the Avahi example code"""
        if self.entry_group_state_changed_match is not None:
            self.entry_group_state_changed_match.remove()
            self.entry_group_state_changed_match = None
        if self.group is not None:
            self.group.Reset()
    def add(self):
        """Derived from the Avahi example code"""
        self.remove()
        if self.group is None:
            self.group = dbus.Interface(
                self.bus.get_object(avahi.DBUS_NAME,
                                    self.server.EntryGroupNew()),
                avahi.DBUS_INTERFACE_ENTRY_GROUP)
        self.entry_group_state_changed_match = (
            self.group.connect_to_signal(
                'StateChanged', self.entry_group_state_changed))
        logger.debug("Adding Zeroconf service '%s' of type '%s' ...",
                     self.name, self.type)
        self.group.AddService(
            self.interface,
            self.protocol,
            dbus.UInt32(0),     # flags
            self.name, self.type,
            self.domain, self.host,
            dbus.UInt16(self.port),
            avahi.string_array_to_txt_array(self.TXT))
        self.group.Commit()
    def entry_group_state_changed(self, state, error):
        """Derived from the Avahi example code"""
        logger.debug("Avahi entry group state change: %i", state)
        
        if state == avahi.ENTRY_GROUP_ESTABLISHED:
            logger.debug("Zeroconf service established.")
        elif state == avahi.ENTRY_GROUP_COLLISION:
            logger.info("Zeroconf service name collision.")
            self.rename()
        elif state == avahi.ENTRY_GROUP_FAILURE:
            logger.critical("Avahi: Error in group state changed %s",
                            unicode(error))
            raise AvahiGroupError("State changed: %s"
                                  % unicode(error))
    def cleanup(self):
        """Derived from the Avahi example code"""
        if self.group is not None:
            try:
                self.group.Free()
            except (dbus.exceptions.UnknownMethodException,
                    dbus.exceptions.DBusException):
                pass
            self.group = None
        self.remove()
    def server_state_changed(self, state, error=None):
        """Derived from the Avahi example code"""
        logger.debug("Avahi server state change: %i", state)
        bad_states = { avahi.SERVER_INVALID:
                           "Zeroconf server invalid",
                       avahi.SERVER_REGISTERING: None,
                       avahi.SERVER_COLLISION:
                           "Zeroconf server name collision",
                       avahi.SERVER_FAILURE:
                           "Zeroconf server failure" }
        if state in bad_states:
            if bad_states[state] is not None:
                if error is None:
                    logger.error(bad_states[state])
                else:
                    logger.error(bad_states[state] + ": %r", error)
            self.cleanup()
        elif state == avahi.SERVER_RUNNING:
            self.add()
        else:
            if error is None:
                logger.debug("Unknown state: %r", state)
            else:
                logger.debug("Unknown state: %r: %r", state, error)
    def activate(self):
        """Derived from the Avahi example code"""
        if self.server is None:
            self.server = dbus.Interface(
                self.bus.get_object(avahi.DBUS_NAME,
                                    avahi.DBUS_PATH_SERVER,
                                    follow_name_owner_changes=True),
                avahi.DBUS_INTERFACE_SERVER)
        self.server.connect_to_signal("StateChanged",
                                 self.server_state_changed)
        self.server_state_changed(self.server.GetState())

class AvahiServiceToSyslog(AvahiService):
    def rename(self):
        """Add the new name to the syslog messages"""
        ret = AvahiService.rename(self)
        syslogger.setFormatter(logging.Formatter
                               ('Mandos (%s) [%%(process)d]:'
                                ' %%(levelname)s: %%(message)s'
                                % self.name))
        return ret

def timedelta_to_milliseconds(td):
    "Convert a datetime.timedelta() to milliseconds"
    return ((td.days * 24 * 60 * 60 * 1000)
            + (td.seconds * 1000)
            + (td.microseconds // 1000))
        
class Client(object):
    """A representation of a client host served by this server.
    
    Attributes:
    approved:   bool(); 'None' if not yet approved/disapproved
    approval_delay: datetime.timedelta(); Time to wait for approval
    approval_duration: datetime.timedelta(); Duration of one approval
    checker:    subprocess.Popen(); a running checker process used
                                    to see if the client lives.
                                    'None' if no process is running.
    checker_callback_tag: a gobject event source tag, or None
    checker_command: string; External command which is run to check
                     if client lives.  %() expansions are done at
                     runtime with vars(self) as dict, so that for
                     instance %(name)s can be used in the command.
    checker_initiator_tag: a gobject event source tag, or None
    created:    datetime.datetime(); (UTC) object creation
    client_structure: Object describing what attributes a client has
                      and is used for storing the client at exit
    current_checker_command: string; current running checker_command
    disable_initiator_tag: a gobject event source tag, or None
    enabled:    bool()
    fingerprint: string (40 or 32 hexadecimal digits); used to
                 uniquely identify the client
    host:       string; available for use by the checker command
    interval:   datetime.timedelta(); How often to start a new checker
    last_approval_request: datetime.datetime(); (UTC) or None
    last_checked_ok: datetime.datetime(); (UTC) or None
    last_checker_status: integer between 0 and 255 reflecting exit
                         status of last checker. -1 reflects crashed
                         checker, -2 means no checker completed yet.
    last_enabled: datetime.datetime(); (UTC) or None
    name:       string; from the config file, used in log messages and
                        D-Bus identifiers
    secret:     bytestring; sent verbatim (over TLS) to client
    timeout:    datetime.timedelta(); How long from last_checked_ok
                                      until this client is disabled
    extended_timeout:   extra long timeout when secret has been sent
    runtime_expansions: Allowed attributes for runtime expansion.
    expires:    datetime.datetime(); time (UTC) when a client will be
                disabled, or None
    """
    
    runtime_expansions = ("approval_delay", "approval_duration",
                          "created", "enabled", "fingerprint",
                          "host", "interval", "last_checked_ok",
                          "last_enabled", "name", "timeout")
    client_defaults = { "timeout": "5m",
                        "extended_timeout": "15m",
                        "interval": "2m",
                        "checker": "fping -q -- %%(host)s",
                        "host": "",
                        "approval_delay": "0s",
                        "approval_duration": "1s",
                        "approved_by_default": "True",
                        "enabled": "True",
                        }
    
    def timeout_milliseconds(self):
        "Return the 'timeout' attribute in milliseconds"
        return timedelta_to_milliseconds(self.timeout)
    
    def extended_timeout_milliseconds(self):
        "Return the 'extended_timeout' attribute in milliseconds"
        return timedelta_to_milliseconds(self.extended_timeout)
    
    def interval_milliseconds(self):
        "Return the 'interval' attribute in milliseconds"
        return timedelta_to_milliseconds(self.interval)
    
    def approval_delay_milliseconds(self):
        return timedelta_to_milliseconds(self.approval_delay)

    @staticmethod
    def config_parser(config):
        """Construct a new dict of client settings of this form:
        { client_name: {setting_name: value, ...}, ...}
        with exceptions for any special settings as defined above.
        NOTE: Must be a pure function. Must return the same result
        value given the same arguments.
        """
        settings = {}
        for client_name in config.sections():
            section = dict(config.items(client_name))
            client = settings[client_name] = {}
            
            client["host"] = section["host"]
            # Reformat values from string types to Python types
            client["approved_by_default"] = config.getboolean(
                client_name, "approved_by_default")
            client["enabled"] = config.getboolean(client_name,
                                                  "enabled")
            
            client["fingerprint"] = (section["fingerprint"].upper()
                                     .replace(" ", ""))
            if "secret" in section:
                client["secret"] = section["secret"].decode("base64")
            elif "secfile" in section:
                with open(os.path.expanduser(os.path.expandvars
                                             (section["secfile"])),
                          "rb") as secfile:
                    client["secret"] = secfile.read()
            else:
                raise TypeError("No secret or secfile for section %s"
                                % section)
            client["timeout"] = string_to_delta(section["timeout"])
            client["extended_timeout"] = string_to_delta(
                section["extended_timeout"])
            client["interval"] = string_to_delta(section["interval"])
            client["approval_delay"] = string_to_delta(
                section["approval_delay"])
            client["approval_duration"] = string_to_delta(
                section["approval_duration"])
            client["checker_command"] = section["checker"]
            client["last_approval_request"] = None
            client["last_checked_ok"] = None
            client["last_checker_status"] = -2
        
        return settings
        
        
    def __init__(self, settings, name = None):
        """Note: the 'checker' key in 'config' sets the
        'checker_command' attribute and *not* the 'checker'
        attribute."""
        self.name = name
        # adding all client settings
        for setting, value in settings.iteritems():
            setattr(self, setting, value)
        
        if self.enabled:
            if not hasattr(self, "last_enabled"):
                self.last_enabled = datetime.datetime.utcnow()
            if not hasattr(self, "expires"):
                self.expires = (datetime.datetime.utcnow()
                                + self.timeout)
        else:
            self.last_enabled = None
            self.expires = None
       
        logger.debug("Creating client %r", self.name)
        # Uppercase and remove spaces from fingerprint for later
        # comparison purposes with return value from the fingerprint()
        # function
        logger.debug("  Fingerprint: %s", self.fingerprint)
        self.created = settings.get("created",
                                    datetime.datetime.utcnow())

        # attributes specific for this server instance
        self.checker = None
        self.checker_initiator_tag = None
        self.disable_initiator_tag = None
        self.checker_callback_tag = None
        self.current_checker_command = None
        self.approved = None
        self.approvals_pending = 0
        self.changedstate = (multiprocessing_manager
                             .Condition(multiprocessing_manager
                                        .Lock()))
        self.client_structure = [attr for attr in
                                 self.__dict__.iterkeys()
                                 if not attr.startswith("_")]
        self.client_structure.append("client_structure")
        
        for name, t in inspect.getmembers(type(self),
                                          lambda obj:
                                              isinstance(obj,
                                                         property)):
            if not name.startswith("_"):
                self.client_structure.append(name)
    
    # Send notice to process children that client state has changed
    def send_changedstate(self):
        with self.changedstate:
            self.changedstate.notify_all()
    
    def enable(self):
        """Start this client's checker and timeout hooks"""
        if getattr(self, "enabled", False):
            # Already enabled
            return
        self.send_changedstate()
        self.expires = datetime.datetime.utcnow() + self.timeout
        self.enabled = True
        self.last_enabled = datetime.datetime.utcnow()
        self.init_checker()
    
    def disable(self, quiet=True):
        """Disable this client."""
        if not getattr(self, "enabled", False):
            return False
        if not quiet:
            self.send_changedstate()
        if not quiet:
            logger.info("Disabling client %s", self.name)
        if getattr(self, "disable_initiator_tag", False):
            gobject.source_remove(self.disable_initiator_tag)
            self.disable_initiator_tag = None
        self.expires = None
        if getattr(self, "checker_initiator_tag", False):
            gobject.source_remove(self.checker_initiator_tag)
            self.checker_initiator_tag = None
        self.stop_checker()
        self.enabled = False
        # Do not run this again if called by a gobject.timeout_add
        return False
    
    def __del__(self):
        self.disable()
    
    def init_checker(self):
        # Schedule a new checker to be started an 'interval' from now,
        # and every interval from then on.
        self.checker_initiator_tag = (gobject.timeout_add
                                      (self.interval_milliseconds(),
                                       self.start_checker))
        # Schedule a disable() when 'timeout' has passed
        self.disable_initiator_tag = (gobject.timeout_add
                                   (self.timeout_milliseconds(),
                                    self.disable))
        # Also start a new checker *right now*.
        self.start_checker()
    
    def checker_callback(self, pid, condition, command):
        """The checker has completed, so take appropriate actions."""
        self.checker_callback_tag = None
        self.checker = None
        if os.WIFEXITED(condition):
            self.last_checker_status = os.WEXITSTATUS(condition)
            if self.last_checker_status == 0:
                logger.info("Checker for %(name)s succeeded",
                            vars(self))
                self.checked_ok()
            else:
                logger.info("Checker for %(name)s failed",
                            vars(self))
        else:
            self.last_checker_status = -1
            logger.warning("Checker for %(name)s crashed?",
                           vars(self))
    
    def checked_ok(self):
        """Assert that the client has been seen, alive and well."""
        self.last_checked_ok = datetime.datetime.utcnow()
        self.last_checker_status = 0
        self.bump_timeout()
    
    def bump_timeout(self, timeout=None):
        """Bump up the timeout for this client."""
        if timeout is None:
            timeout = self.timeout
        if self.disable_initiator_tag is not None:
            gobject.source_remove(self.disable_initiator_tag)
        if getattr(self, "enabled", False):
            self.disable_initiator_tag = (gobject.timeout_add
                                          (timedelta_to_milliseconds
                                           (timeout), self.disable))
            self.expires = datetime.datetime.utcnow() + timeout
    
    def need_approval(self):
        self.last_approval_request = datetime.datetime.utcnow()
    
    def start_checker(self):
        """Start a new checker subprocess if one is not running.
        
        If a checker already exists, leave it running and do
        nothing."""
        # The reason for not killing a running checker is that if we
        # did that, then if a checker (for some reason) started
        # running slowly and taking more than 'interval' time, the
        # client would inevitably timeout, since no checker would get
        # a chance to run to completion.  If we instead leave running
        # checkers alone, the checker would have to take more time
        # than 'timeout' for the client to be disabled, which is as it
        # should be.
        
        # If a checker exists, make sure it is not a zombie
        try:
            pid, status = os.waitpid(self.checker.pid, os.WNOHANG)
        except (AttributeError, OSError) as error:
            if (isinstance(error, OSError)
                and error.errno != errno.ECHILD):
                raise error
        else:
            if pid:
                logger.warning("Checker was a zombie")
                gobject.source_remove(self.checker_callback_tag)
                self.checker_callback(pid, status,
                                      self.current_checker_command)
        # Start a new checker if needed
        if self.checker is None:
            try:
                # In case checker_command has exactly one % operator
                command = self.checker_command % self.host
            except TypeError:
                # Escape attributes for the shell
                escaped_attrs = dict(
                    (attr,
                     re.escape(unicode(str(getattr(self, attr, "")),
                                       errors=
                                       'replace')))
                    for attr in
                    self.runtime_expansions)
                
                try:
                    command = self.checker_command % escaped_attrs
                except TypeError as error:
                    logger.error('Could not format string "%s"',
                                 self.checker_command, exc_info=error)
                    return True # Try again later
            self.current_checker_command = command
            try:
                logger.info("Starting checker %r for %s",
                            command, self.name)
                # We don't need to redirect stdout and stderr, since
                # in normal mode, that is already done by daemon(),
                # and in debug mode we don't want to.  (Stdin is
                # always replaced by /dev/null.)
                self.checker = subprocess.Popen(command,
                                                close_fds=True,
                                                shell=True, cwd="/")
                self.checker_callback_tag = (gobject.child_watch_add
                                             (self.checker.pid,
                                              self.checker_callback,
                                              data=command))
                # The checker may have completed before the gobject
                # watch was added.  Check for this.
                pid, status = os.waitpid(self.checker.pid, os.WNOHANG)
                if pid:
                    gobject.source_remove(self.checker_callback_tag)
                    self.checker_callback(pid, status, command)
            except OSError as error:
                logger.error("Failed to start subprocess",
                             exc_info=error)
        # Re-run this periodically if run by gobject.timeout_add
        return True
    
    def stop_checker(self):
        """Force the checker process, if any, to stop."""
        if self.checker_callback_tag:
            gobject.source_remove(self.checker_callback_tag)
            self.checker_callback_tag = None
        if getattr(self, "checker", None) is None:
            return
        logger.debug("Stopping checker for %(name)s", vars(self))
        try:
            self.checker.terminate()
            #time.sleep(0.5)
            #if self.checker.poll() is None:
            #    self.checker.kill()
        except OSError as error:
            if error.errno != errno.ESRCH: # No such process
                raise
        self.checker = None


def dbus_service_property(dbus_interface, signature="v",
                          access="readwrite", byte_arrays=False):
    """Decorators for marking methods of a DBusObjectWithProperties to
    become properties on the D-Bus.
    
    The decorated method will be called with no arguments by "Get"
    and with one argument by "Set".
    
    The parameters, where they are supported, are the same as
    dbus.service.method, except there is only "signature", since the
    type from Get() and the type sent to Set() is the same.
    """
    # Encoding deeply encoded byte arrays is not supported yet by the
    # "Set" method, so we fail early here:
    if byte_arrays and signature != "ay":
        raise ValueError("Byte arrays not supported for non-'ay'"
                         " signature %r" % signature)
    def decorator(func):
        func._dbus_is_property = True
        func._dbus_interface = dbus_interface
        func._dbus_signature = signature
        func._dbus_access = access
        func._dbus_name = func.__name__
        if func._dbus_name.endswith("_dbus_property"):
            func._dbus_name = func._dbus_name[:-14]
        func._dbus_get_args_options = {'byte_arrays': byte_arrays }
        return func
    return decorator


def dbus_interface_annotations(dbus_interface):
    """Decorator for marking functions returning interface annotations.
    
    Usage:
    
    @dbus_interface_annotations("org.example.Interface")
    def _foo(self):  # Function name does not matter
        return {"org.freedesktop.DBus.Deprecated": "true",
                "org.freedesktop.DBus.Property.EmitsChangedSignal":
                    "false"}
    """
    def decorator(func):
        func._dbus_is_interface = True
        func._dbus_interface = dbus_interface
        func._dbus_name = dbus_interface
        return func
    return decorator


def dbus_annotations(annotations):
    """Decorator to annotate D-Bus methods, signals or properties
    Usage:
    
    @dbus_service_property("org.example.Interface", signature="b",
                           access="r")
    @dbus_annotations({{"org.freedesktop.DBus.Deprecated": "true",
                        "org.freedesktop.DBus.Property."
                        "EmitsChangedSignal": "false"})
    def Property_dbus_property(self):
        return dbus.Boolean(False)
    """
    def decorator(func):
        func._dbus_annotations = annotations
        return func
    return decorator


class DBusPropertyException(dbus.exceptions.DBusException):
    """A base class for D-Bus property-related exceptions
    """
    def __unicode__(self):
        return unicode(str(self))


class DBusPropertyAccessException(DBusPropertyException):
    """A property's access permissions disallows an operation.
    """
    pass


class DBusPropertyNotFound(DBusPropertyException):
    """An attempt was made to access a non-existing property.
    """
    pass


class DBusObjectWithProperties(dbus.service.Object):
    """A D-Bus object with properties.
    
    Classes inheriting from this can use the dbus_service_property
    decorator to expose methods as D-Bus properties.  It exposes the
    standard Get(), Set(), and GetAll() methods on the D-Bus.
    """
    
    @staticmethod
    def _is_dbus_thing(thing):
        """Returns a function testing if an attribute is a D-Bus thing
        
        If called like _is_dbus_thing("method") it returns a function
        suitable for use as predicate to inspect.getmembers().
        """
        return lambda obj: getattr(obj, "_dbus_is_{0}".format(thing),
                                   False)
    
    def _get_all_dbus_things(self, thing):
        """Returns a generator of (name, attribute) pairs
        """
        return ((getattr(athing.__get__(self), "_dbus_name",
                         name),
                 athing.__get__(self))
                for cls in self.__class__.__mro__
                for name, athing in
                inspect.getmembers(cls,
                                   self._is_dbus_thing(thing)))
    
    def _get_dbus_property(self, interface_name, property_name):
        """Returns a bound method if one exists which is a D-Bus
        property with the specified name and interface.
        """
        for cls in  self.__class__.__mro__:
            for name, value in (inspect.getmembers
                                (cls,
                                 self._is_dbus_thing("property"))):
                if (value._dbus_name == property_name
                    and value._dbus_interface == interface_name):
                    return value.__get__(self)
        
        # No such property
        raise DBusPropertyNotFound(self.dbus_object_path + ":"
                                   + interface_name + "."
                                   + property_name)
    
    @dbus.service.method(dbus.PROPERTIES_IFACE, in_signature="ss",
                         out_signature="v")
    def Get(self, interface_name, property_name):
        """Standard D-Bus property Get() method, see D-Bus standard.
        """
        prop = self._get_dbus_property(interface_name, property_name)
        if prop._dbus_access == "write":
            raise DBusPropertyAccessException(property_name)
        value = prop()
        if not hasattr(value, "variant_level"):
            return value
        return type(value)(value, variant_level=value.variant_level+1)
    
    @dbus.service.method(dbus.PROPERTIES_IFACE, in_signature="ssv")
    def Set(self, interface_name, property_name, value):
        """Standard D-Bus property Set() method, see D-Bus standard.
        """
        prop = self._get_dbus_property(interface_name, property_name)
        if prop._dbus_access == "read":
            raise DBusPropertyAccessException(property_name)
        if prop._dbus_get_args_options["byte_arrays"]:
            # The byte_arrays option is not supported yet on
            # signatures other than "ay".
            if prop._dbus_signature != "ay":
                raise ValueError
            value = dbus.ByteArray(b''.join(chr(byte)
                                            for byte in value))
        prop(value)
    
    @dbus.service.method(dbus.PROPERTIES_IFACE, in_signature="s",
                         out_signature="a{sv}")
    def GetAll(self, interface_name):
        """Standard D-Bus property GetAll() method, see D-Bus
        standard.
        
        Note: Will not include properties with access="write".
        """
        properties = {}
        for name, prop in self._get_all_dbus_things("property"):
            if (interface_name
                and interface_name != prop._dbus_interface):
                # Interface non-empty but did not match
                continue
            # Ignore write-only properties
            if prop._dbus_access == "write":
                continue
            value = prop()
            if not hasattr(value, "variant_level"):
                properties[name] = value
                continue
            properties[name] = type(value)(value, variant_level=
                                           value.variant_level+1)
        return dbus.Dictionary(properties, signature="sv")
    
    @dbus.service.method(dbus.INTROSPECTABLE_IFACE,
                         out_signature="s",
                         path_keyword='object_path',
                         connection_keyword='connection')
    def Introspect(self, object_path, connection):
        """Overloading of standard D-Bus method.
        
        Inserts property tags and interface annotation tags.
        """
        xmlstring = dbus.service.Object.Introspect(self, object_path,
                                                   connection)
        try:
            document = xml.dom.minidom.parseString(xmlstring)
            def make_tag(document, name, prop):
                e = document.createElement("property")
                e.setAttribute("name", name)
                e.setAttribute("type", prop._dbus_signature)
                e.setAttribute("access", prop._dbus_access)
                return e
            for if_tag in document.getElementsByTagName("interface"):
                # Add property tags
                for tag in (make_tag(document, name, prop)
                            for name, prop
                            in self._get_all_dbus_things("property")
                            if prop._dbus_interface
                            == if_tag.getAttribute("name")):
                    if_tag.appendChild(tag)
                # Add annotation tags
                for typ in ("method", "signal", "property"):
                    for tag in if_tag.getElementsByTagName(typ):
                        annots = dict()
                        for name, prop in (self.
                                           _get_all_dbus_things(typ)):
                            if (name == tag.getAttribute("name")
                                and prop._dbus_interface
                                == if_tag.getAttribute("name")):
                                annots.update(getattr
                                              (prop,
                                               "_dbus_annotations",
                                               {}))
                        for name, value in annots.iteritems():
                            ann_tag = document.createElement(
                                "annotation")
                            ann_tag.setAttribute("name", name)
                            ann_tag.setAttribute("value", value)
                            tag.appendChild(ann_tag)
                # Add interface annotation tags
                for annotation, value in dict(
                    itertools.chain(
                        *(annotations().iteritems()
                          for name, annotations in
                          self._get_all_dbus_things("interface")
                          if name == if_tag.getAttribute("name")
                          ))).iteritems():
                    ann_tag = document.createElement("annotation")
                    ann_tag.setAttribute("name", annotation)
                    ann_tag.setAttribute("value", value)
                    if_tag.appendChild(ann_tag)
                # Add the names to the return values for the
                # "org.freedesktop.DBus.Properties" methods
                if (if_tag.getAttribute("name")
                    == "org.freedesktop.DBus.Properties"):
                    for cn in if_tag.getElementsByTagName("method"):
                        if cn.getAttribute("name") == "Get":
                            for arg in cn.getElementsByTagName("arg"):
                                if (arg.getAttribute("direction")
                                    == "out"):
                                    arg.setAttribute("name", "value")
                        elif cn.getAttribute("name") == "GetAll":
                            for arg in cn.getElementsByTagName("arg"):
                                if (arg.getAttribute("direction")
                                    == "out"):
                                    arg.setAttribute("name", "props")
            xmlstring = document.toxml("utf-8")
            document.unlink()
        except (AttributeError, xml.dom.DOMException,
                xml.parsers.expat.ExpatError) as error:
            logger.error("Failed to override Introspection method",
                         exc_info=error)
        return xmlstring


def datetime_to_dbus (dt, variant_level=0):
    """Convert a UTC datetime.datetime() to a D-Bus type."""
    if dt is None:
        return dbus.String("", variant_level = variant_level)
    return dbus.String(dt.isoformat(),
                       variant_level=variant_level)


class AlternateDBusNamesMetaclass(DBusObjectWithProperties
                                  .__metaclass__):
    """Applied to an empty subclass of a D-Bus object, this metaclass
    will add additional D-Bus attributes matching a certain pattern.
    """
    def __new__(mcs, name, bases, attr):
        # Go through all the base classes which could have D-Bus
        # methods, signals, or properties in them
        old_interface_names = []
        for base in (b for b in bases
                     if issubclass(b, dbus.service.Object)):
            # Go though all attributes of the base class
            for attrname, attribute in inspect.getmembers(base):
                # Ignore non-D-Bus attributes, and D-Bus attributes
                # with the wrong interface name
                if (not hasattr(attribute, "_dbus_interface")
                    or not attribute._dbus_interface
                    .startswith("se.recompile.Mandos")):
                    continue
                # Create an alternate D-Bus interface name based on
                # the current name
                alt_interface = (attribute._dbus_interface
                                 .replace("se.recompile.Mandos",
                                          "se.bsnet.fukt.Mandos"))
                if alt_interface != attribute._dbus_interface:
                    old_interface_names.append(alt_interface)
                # Is this a D-Bus signal?
                if getattr(attribute, "_dbus_is_signal", False):
                    # Extract the original non-method function by
                    # black magic
                    nonmethod_func = (dict(
                            zip(attribute.func_code.co_freevars,
                                attribute.__closure__))["func"]
                                      .cell_contents)
                    # Create a new, but exactly alike, function
                    # object, and decorate it to be a new D-Bus signal
                    # with the alternate D-Bus interface name
                    new_function = (dbus.service.signal
                                    (alt_interface,
                                     attribute._dbus_signature)
                                    (types.FunctionType(
                                nonmethod_func.func_code,
                                nonmethod_func.func_globals,
                                nonmethod_func.func_name,
                                nonmethod_func.func_defaults,
                                nonmethod_func.func_closure)))
                    # Copy annotations, if any
                    try:
                        new_function._dbus_annotations = (
                            dict(attribute._dbus_annotations))
                    except AttributeError:
                        pass
                    # Define a creator of a function to call both the
                    # old and new functions, so both the old and new
                    # signals gets sent when the function is called
                    def fixscope(func1, func2):
                        """This function is a scope container to pass
                        func1 and func2 to the "call_both" function
                        outside of its arguments"""
                        def call_both(*args, **kwargs):
                            """This function will emit two D-Bus
                            signals by calling func1 and func2"""
                            func1(*args, **kwargs)
                            func2(*args, **kwargs)
                        return call_both
                    # Create the "call_both" function and add it to
                    # the class
                    attr[attrname] = fixscope(attribute,
                                              new_function)
                # Is this a D-Bus method?
                elif getattr(attribute, "_dbus_is_method", False):
                    # Create a new, but exactly alike, function
                    # object.  Decorate it to be a new D-Bus method
                    # with the alternate D-Bus interface name.  Add it
                    # to the class.
                    attr[attrname] = (dbus.service.method
                                      (alt_interface,
                                       attribute._dbus_in_signature,
                                       attribute._dbus_out_signature)
                                      (types.FunctionType
                                       (attribute.func_code,
                                        attribute.func_globals,
                                        attribute.func_name,
                                        attribute.func_defaults,
                                        attribute.func_closure)))
                    # Copy annotations, if any
                    try:
                        attr[attrname]._dbus_annotations = (
                            dict(attribute._dbus_annotations))
                    except AttributeError:
                        pass
                # Is this a D-Bus property?
                elif getattr(attribute, "_dbus_is_property", False):
                    # Create a new, but exactly alike, function
                    # object, and decorate it to be a new D-Bus
                    # property with the alternate D-Bus interface
                    # name.  Add it to the class.
                    attr[attrname] = (dbus_service_property
                                      (alt_interface,
                                       attribute._dbus_signature,
                                       attribute._dbus_access,
                                       attribute
                                       ._dbus_get_args_options
                                       ["byte_arrays"])
                                      (types.FunctionType
                                       (attribute.func_code,
                                        attribute.func_globals,
                                        attribute.func_name,
                                        attribute.func_defaults,
                                        attribute.func_closure)))
                    # Copy annotations, if any
                    try:
                        attr[attrname]._dbus_annotations = (
                            dict(attribute._dbus_annotations))
                    except AttributeError:
                        pass
                # Is this a D-Bus interface?
                elif getattr(attribute, "_dbus_is_interface", False):
                    # Create a new, but exactly alike, function
                    # object.  Decorate it to be a new D-Bus interface
                    # with the alternate D-Bus interface name.  Add it
                    # to the class.
                    attr[attrname] = (dbus_interface_annotations
                                      (alt_interface)
                                      (types.FunctionType
                                       (attribute.func_code,
                                        attribute.func_globals,
                                        attribute.func_name,
                                        attribute.func_defaults,
                                        attribute.func_closure)))
        # Deprecate all old interfaces
        basename="_AlternateDBusNamesMetaclass_interface_annotation{0}"
        for old_interface_name in old_interface_names:
            @dbus_interface_annotations(old_interface_name)
            def func(self):
                return { "org.freedesktop.DBus.Deprecated": "true" }
            # Find an unused name
            for aname in (basename.format(i) for i in
                          itertools.count()):
                if aname not in attr:
                    attr[aname] = func
                    break
        return type.__new__(mcs, name, bases, attr)


class ClientDBus(Client, DBusObjectWithProperties):
    """A Client class using D-Bus
    
    Attributes:
    dbus_object_path: dbus.ObjectPath
    bus: dbus.SystemBus()
    """
    
    runtime_expansions = (Client.runtime_expansions
                          + ("dbus_object_path",))
    
    # dbus.service.Object doesn't use super(), so we can't either.
    
    def __init__(self, bus = None, *args, **kwargs):
        self.bus = bus
        Client.__init__(self, *args, **kwargs)
        # Only now, when this client is initialized, can it show up on
        # the D-Bus
        client_object_name = unicode(self.name).translate(
            {ord("."): ord("_"),
             ord("-"): ord("_")})
        self.dbus_object_path = (dbus.ObjectPath
                                 ("/clients/" + client_object_name))
        DBusObjectWithProperties.__init__(self, self.bus,
                                          self.dbus_object_path)
        
    def notifychangeproperty(transform_func,
                             dbus_name, type_func=lambda x: x,
                             variant_level=1):
        """ Modify a variable so that it's a property which announces
        its changes to DBus.
        
        transform_fun: Function that takes a value and a variant_level
                       and transforms it to a D-Bus type.
        dbus_name: D-Bus name of the variable
        type_func: Function that transform the value before sending it
                   to the D-Bus.  Default: no transform
        variant_level: D-Bus variant level.  Default: 1
        """
        attrname = "_{0}".format(dbus_name)
        def setter(self, value):
            if hasattr(self, "dbus_object_path"):
                if (not hasattr(self, attrname) or
                    type_func(getattr(self, attrname, None))
                    != type_func(value)):
                    dbus_value = transform_func(type_func(value),
                                                variant_level
                                                =variant_level)
                    self.PropertyChanged(dbus.String(dbus_name),
                                         dbus_value)
            setattr(self, attrname, value)
        
        return property(lambda self: getattr(self, attrname), setter)
    
    
    expires = notifychangeproperty(datetime_to_dbus, "Expires")
    approvals_pending = notifychangeproperty(dbus.Boolean,
                                             "ApprovalPending",
                                             type_func = bool)
    enabled = notifychangeproperty(dbus.Boolean, "Enabled")
    last_enabled = notifychangeproperty(datetime_to_dbus,
                                        "LastEnabled")
    checker = notifychangeproperty(dbus.Boolean, "CheckerRunning",
                                   type_func = lambda checker:
                                       checker is not None)
    last_checked_ok = notifychangeproperty(datetime_to_dbus,
                                           "LastCheckedOK")
    last_checker_status = notifychangeproperty(dbus.Int16,
                                               "LastCheckerStatus")
    last_approval_request = notifychangeproperty(
        datetime_to_dbus, "LastApprovalRequest")
    approved_by_default = notifychangeproperty(dbus.Boolean,
                                               "ApprovedByDefault")
    approval_delay = notifychangeproperty(dbus.UInt64,
                                          "ApprovalDelay",
                                          type_func =
                                          timedelta_to_milliseconds)
    approval_duration = notifychangeproperty(
        dbus.UInt64, "ApprovalDuration",
        type_func = timedelta_to_milliseconds)
    host = notifychangeproperty(dbus.String, "Host")
    timeout = notifychangeproperty(dbus.UInt64, "Timeout",
                                   type_func =
                                   timedelta_to_milliseconds)
    extended_timeout = notifychangeproperty(
        dbus.UInt64, "ExtendedTimeout",
        type_func = timedelta_to_milliseconds)
    interval = notifychangeproperty(dbus.UInt64,
                                    "Interval",
                                    type_func =
                                    timedelta_to_milliseconds)
    checker_command = notifychangeproperty(dbus.String, "Checker")
    
    del notifychangeproperty
    
    def __del__(self, *args, **kwargs):
        try:
            self.remove_from_connection()
        except LookupError:
            pass
        if hasattr(DBusObjectWithProperties, "__del__"):
            DBusObjectWithProperties.__del__(self, *args, **kwargs)
        Client.__del__(self, *args, **kwargs)
    
    def checker_callback(self, pid, condition, command,
                         *args, **kwargs):
        self.checker_callback_tag = None
        self.checker = None
        if os.WIFEXITED(condition):
            exitstatus = os.WEXITSTATUS(condition)
            # Emit D-Bus signal
            self.CheckerCompleted(dbus.Int16(exitstatus),
                                  dbus.Int64(condition),
                                  dbus.String(command))
        else:
            # Emit D-Bus signal
            self.CheckerCompleted(dbus.Int16(-1),
                                  dbus.Int64(condition),
                                  dbus.String(command))
        
        return Client.checker_callback(self, pid, condition, command,
                                       *args, **kwargs)
    
    def start_checker(self, *args, **kwargs):
        old_checker = self.checker
        if self.checker is not None:
            old_checker_pid = self.checker.pid
        else:
            old_checker_pid = None
        r = Client.start_checker(self, *args, **kwargs)
        # Only if new checker process was started
        if (self.checker is not None
            and old_checker_pid != self.checker.pid):
            # Emit D-Bus signal
            self.CheckerStarted(self.current_checker_command)
        return r
    
    def _reset_approved(self):
        self.approved = None
        return False
    
    def approve(self, value=True):
        self.send_changedstate()
        self.approved = value
        gobject.timeout_add(timedelta_to_milliseconds
                            (self.approval_duration),
                            self._reset_approved)
    
    
    ## D-Bus methods, signals & properties
    _interface = "se.recompile.Mandos.Client"
    
    ## Interfaces
    
    @dbus_interface_annotations(_interface)
    def _foo(self):
        return { "org.freedesktop.DBus.Property.EmitsChangedSignal":
                     "false"}
    
    ## Signals
    
    # CheckerCompleted - signal
    @dbus.service.signal(_interface, signature="nxs")
    def CheckerCompleted(self, exitcode, waitstatus, command):
        "D-Bus signal"
        pass
    
    # CheckerStarted - signal
    @dbus.service.signal(_interface, signature="s")
    def CheckerStarted(self, command):
        "D-Bus signal"
        pass
    
    # PropertyChanged - signal
    @dbus.service.signal(_interface, signature="sv")
    def PropertyChanged(self, property, value):
        "D-Bus signal"
        pass
    
    # GotSecret - signal
    @dbus.service.signal(_interface)
    def GotSecret(self):
        """D-Bus signal
        Is sent after a successful transfer of secret from the Mandos
        server to mandos-client
        """
        pass
    
    # Rejected - signal
    @dbus.service.signal(_interface, signature="s")
    def Rejected(self, reason):
        "D-Bus signal"
        pass
    
    # NeedApproval - signal
    @dbus.service.signal(_interface, signature="tb")
    def NeedApproval(self, timeout, default):
        "D-Bus signal"
        return self.need_approval()
    
    ## Methods
    
    # Approve - method
    @dbus.service.method(_interface, in_signature="b")
    def Approve(self, value):
        self.approve(value)
    
    # CheckedOK - method
    @dbus.service.method(_interface)
    def CheckedOK(self):
        self.checked_ok()
    
    # Enable - method
    @dbus.service.method(_interface)
    def Enable(self):
        "D-Bus method"
        self.enable()
    
    # StartChecker - method
    @dbus.service.method(_interface)
    def StartChecker(self):
        "D-Bus method"
        self.start_checker()
    
    # Disable - method
    @dbus.service.method(_interface)
    def Disable(self):
        "D-Bus method"
        self.disable()
    
    # StopChecker - method
    @dbus.service.method(_interface)
    def StopChecker(self):
        self.stop_checker()
    
    ## Properties
    
    # ApprovalPending - property
    @dbus_service_property(_interface, signature="b", access="read")
    def ApprovalPending_dbus_property(self):
        return dbus.Boolean(bool(self.approvals_pending))
    
    # ApprovedByDefault - property
    @dbus_service_property(_interface, signature="b",
                           access="readwrite")
    def ApprovedByDefault_dbus_property(self, value=None):
        if value is None:       # get
            return dbus.Boolean(self.approved_by_default)
        self.approved_by_default = bool(value)
    
    # ApprovalDelay - property
    @dbus_service_property(_interface, signature="t",
                           access="readwrite")
    def ApprovalDelay_dbus_property(self, value=None):
        if value is None:       # get
            return dbus.UInt64(self.approval_delay_milliseconds())
        self.approval_delay = datetime.timedelta(0, 0, 0, value)
    
    # ApprovalDuration - property
    @dbus_service_property(_interface, signature="t",
                           access="readwrite")
    def ApprovalDuration_dbus_property(self, value=None):
        if value is None:       # get
            return dbus.UInt64(timedelta_to_milliseconds(
                    self.approval_duration))
        self.approval_duration = datetime.timedelta(0, 0, 0, value)
    
    # Name - property
    @dbus_service_property(_interface, signature="s", access="read")
    def Name_dbus_property(self):
        return dbus.String(self.name)
    
    # Fingerprint - property
    @dbus_service_property(_interface, signature="s", access="read")
    def Fingerprint_dbus_property(self):
        return dbus.String(self.fingerprint)
    
    # Host - property
    @dbus_service_property(_interface, signature="s",
                           access="readwrite")
    def Host_dbus_property(self, value=None):
        if value is None:       # get
            return dbus.String(self.host)
        self.host = unicode(value)
    
    # Created - property
    @dbus_service_property(_interface, signature="s", access="read")
    def Created_dbus_property(self):
        return datetime_to_dbus(self.created)
    
    # LastEnabled - property
    @dbus_service_property(_interface, signature="s", access="read")
    def LastEnabled_dbus_property(self):
        return datetime_to_dbus(self.last_enabled)
    
    # Enabled - property
    @dbus_service_property(_interface, signature="b",
                           access="readwrite")
    def Enabled_dbus_property(self, value=None):
        if value is None:       # get
            return dbus.Boolean(self.enabled)
        if value:
            self.enable()
        else:
            self.disable()
    
    # LastCheckedOK - property
    @dbus_service_property(_interface, signature="s",
                           access="readwrite")
    def LastCheckedOK_dbus_property(self, value=None):
        if value is not None:
            self.checked_ok()
            return
        return datetime_to_dbus(self.last_checked_ok)
    
    # LastCheckerStatus - property
    @dbus_service_property(_interface, signature="n",
                           access="read")
    def LastCheckerStatus_dbus_property(self):
        return dbus.Int16(self.last_checker_status)
    
    # Expires - property
    @dbus_service_property(_interface, signature="s", access="read")
    def Expires_dbus_property(self):
        return datetime_to_dbus(self.expires)
    
    # LastApprovalRequest - property
    @dbus_service_property(_interface, signature="s", access="read")
    def LastApprovalRequest_dbus_property(self):
        return datetime_to_dbus(self.last_approval_request)
    
    # Timeout - property
    @dbus_service_property(_interface, signature="t",
                           access="readwrite")
    def Timeout_dbus_property(self, value=None):
        if value is None:       # get
            return dbus.UInt64(self.timeout_milliseconds())
        self.timeout = datetime.timedelta(0, 0, 0, value)
        # Reschedule timeout
        if self.enabled:
            now = datetime.datetime.utcnow()
            time_to_die = timedelta_to_milliseconds(
                (self.last_checked_ok + self.timeout) - now)
            if time_to_die <= 0:
                # The timeout has passed
                self.disable()
            else:
                self.expires = (now +
                                datetime.timedelta(milliseconds =
                                                   time_to_die))
                if (getattr(self, "disable_initiator_tag", None)
                    is None):
                    return
                gobject.source_remove(self.disable_initiator_tag)
                self.disable_initiator_tag = (gobject.timeout_add
                                              (time_to_die,
                                               self.disable))
    
    # ExtendedTimeout - property
    @dbus_service_property(_interface, signature="t",
                           access="readwrite")
    def ExtendedTimeout_dbus_property(self, value=None):
        if value is None:       # get
            return dbus.UInt64(self.extended_timeout_milliseconds())
        self.extended_timeout = datetime.timedelta(0, 0, 0, value)
    
    # Interval - property
    @dbus_service_property(_interface, signature="t",
                           access="readwrite")
    def Interval_dbus_property(self, value=None):
        if value is None:       # get
            return dbus.UInt64(self.interval_milliseconds())
        self.interval = datetime.timedelta(0, 0, 0, value)
        if getattr(self, "checker_initiator_tag", None) is None:
            return
        if self.enabled:
            # Reschedule checker run
            gobject.source_remove(self.checker_initiator_tag)
            self.checker_initiator_tag = (gobject.timeout_add
                                          (value, self.start_checker))
            self.start_checker()    # Start one now, too
    
    # Checker - property
    @dbus_service_property(_interface, signature="s",
                           access="readwrite")
    def Checker_dbus_property(self, value=None):
        if value is None:       # get
            return dbus.String(self.checker_command)
        self.checker_command = unicode(value)
    
    # CheckerRunning - property
    @dbus_service_property(_interface, signature="b",
                           access="readwrite")
    def CheckerRunning_dbus_property(self, value=None):
        if value is None:       # get
            return dbus.Boolean(self.checker is not None)
        if value:
            self.start_checker()
        else:
            self.stop_checker()
    
    # ObjectPath - property
    @dbus_service_property(_interface, signature="o", access="read")
    def ObjectPath_dbus_property(self):
        return self.dbus_object_path # is already a dbus.ObjectPath
    
    # Secret = property
    @dbus_service_property(_interface, signature="ay",
                           access="write", byte_arrays=True)
    def Secret_dbus_property(self, value):
        self.secret = str(value)
    
    del _interface


class ProxyClient(object):
    def __init__(self, child_pipe, fpr, address):
        self._pipe = child_pipe
        self._pipe.send(('init', fpr, address))
        if not self._pipe.recv():
            raise KeyError()
    
    def __getattribute__(self, name):
        if name == '_pipe':
            return super(ProxyClient, self).__getattribute__(name)
        self._pipe.send(('getattr', name))
        data = self._pipe.recv()
        if data[0] == 'data':
            return data[1]
        if data[0] == 'function':
            def func(*args, **kwargs):
                self._pipe.send(('funcall', name, args, kwargs))
                return self._pipe.recv()[1]
            return func
    
    def __setattr__(self, name, value):
        if name == '_pipe':
            return super(ProxyClient, self).__setattr__(name, value)
        self._pipe.send(('setattr', name, value))


class ClientDBusTransitional(ClientDBus):
    __metaclass__ = AlternateDBusNamesMetaclass


class ClientHandler(socketserver.BaseRequestHandler, object):
    """A class to handle client connections.
    
    Instantiated once for each connection to handle it.
    Note: This will run in its own forked process."""
    
    def handle(self):
        with contextlib.closing(self.server.child_pipe) as child_pipe:
            logger.info("TCP connection from: %s",
                        unicode(self.client_address))
            logger.debug("Pipe FD: %d",
                         self.server.child_pipe.fileno())
            
            session = (gnutls.connection
                       .ClientSession(self.request,
                                      gnutls.connection
                                      .X509Credentials()))
            
            # Note: gnutls.connection.X509Credentials is really a
            # generic GnuTLS certificate credentials object so long as
            # no X.509 keys are added to it.  Therefore, we can use it
            # here despite using OpenPGP certificates.
            
            #priority = ':'.join(("NONE", "+VERS-TLS1.1",
            #                      "+AES-256-CBC", "+SHA1",
            #                      "+COMP-NULL", "+CTYPE-OPENPGP",
            #                      "+DHE-DSS"))
            # Use a fallback default, since this MUST be set.
            priority = self.server.gnutls_priority
            if priority is None:
                priority = "NORMAL"
            (gnutls.library.functions
             .gnutls_priority_set_direct(session._c_object,
                                         priority, None))
            
            # Start communication using the Mandos protocol
            # Get protocol number
            line = self.request.makefile().readline()
            logger.debug("Protocol version: %r", line)
            try:
                if int(line.strip().split()[0]) > 1:
                    raise RuntimeError
            except (ValueError, IndexError, RuntimeError) as error:
                logger.error("Unknown protocol version: %s", error)
                return
            
            # Start GnuTLS connection
            try:
                session.handshake()
            except gnutls.errors.GNUTLSError as error:
                logger.warning("Handshake failed: %s", error)
                # Do not run session.bye() here: the session is not
                # established.  Just abandon the request.
                return
            logger.debug("Handshake succeeded")
            
            approval_required = False
            try:
                try:
                    fpr = self.fingerprint(self.peer_certificate
                                           (session))
                except (TypeError,
                        gnutls.errors.GNUTLSError) as error:
                    logger.warning("Bad certificate: %s", error)
                    return
                logger.debug("Fingerprint: %s", fpr)
                
                try:
                    client = ProxyClient(child_pipe, fpr,
                                         self.client_address)
                except KeyError:
                    return
                
                if client.approval_delay:
                    delay = client.approval_delay
                    client.approvals_pending += 1
                    approval_required = True
                
                while True:
                    if not client.enabled:
                        logger.info("Client %s is disabled",
                                       client.name)
                        if self.server.use_dbus:
                            # Emit D-Bus signal
                            client.Rejected("Disabled")
                        return
                    
                    if client.approved or not client.approval_delay:
                        #We are approved or approval is disabled
                        break
                    elif client.approved is None:
                        logger.info("Client %s needs approval",
                                    client.name)
                        if self.server.use_dbus:
                            # Emit D-Bus signal
                            client.NeedApproval(
                                client.approval_delay_milliseconds(),
                                client.approved_by_default)
                    else:
                        logger.warning("Client %s was not approved",
                                       client.name)
                        if self.server.use_dbus:
                            # Emit D-Bus signal
                            client.Rejected("Denied")
                        return
                    
                    #wait until timeout or approved
                    time = datetime.datetime.now()
                    client.changedstate.acquire()
                    (client.changedstate.wait
                     (float(client.timedelta_to_milliseconds(delay)
                            / 1000)))
                    client.changedstate.release()
                    time2 = datetime.datetime.now()
                    if (time2 - time) >= delay:
                        if not client.approved_by_default:
                            logger.warning("Client %s timed out while"
                                           " waiting for approval",
                                           client.name)
                            if self.server.use_dbus:
                                # Emit D-Bus signal
                                client.Rejected("Approval timed out")
                            return
                        else:
                            break
                    else:
                        delay -= time2 - time
                
                sent_size = 0
                while sent_size < len(client.secret):
                    try:
                        sent = session.send(client.secret[sent_size:])
                    except gnutls.errors.GNUTLSError as error:
                        logger.warning("gnutls send failed")
                        return
                    logger.debug("Sent: %d, remaining: %d",
                                 sent, len(client.secret)
                                 - (sent_size + sent))
                    sent_size += sent
                
                logger.info("Sending secret to %s", client.name)
                # bump the timeout using extended_timeout
                client.bump_timeout(client.extended_timeout)
                if self.server.use_dbus:
                    # Emit D-Bus signal
                    client.GotSecret()
            
            finally:
                if approval_required:
                    client.approvals_pending -= 1
                try:
                    session.bye()
                except gnutls.errors.GNUTLSError as error:
                    logger.warning("GnuTLS bye failed")
    
    @staticmethod
    def peer_certificate(session):
        "Return the peer's OpenPGP certificate as a bytestring"
        # If not an OpenPGP certificate...
        if (gnutls.library.functions
            .gnutls_certificate_type_get(session._c_object)
            != gnutls.library.constants.GNUTLS_CRT_OPENPGP):
            # ...do the normal thing
            return session.peer_certificate
        list_size = ctypes.c_uint(1)
        cert_list = (gnutls.library.functions
                     .gnutls_certificate_get_peers
                     (session._c_object, ctypes.byref(list_size)))
        if not bool(cert_list) and list_size.value != 0:
            raise gnutls.errors.GNUTLSError("error getting peer"
                                            " certificate")
        if list_size.value == 0:
            return None
        cert = cert_list[0]
        return ctypes.string_at(cert.data, cert.size)
    
    @staticmethod
    def fingerprint(openpgp):
        "Convert an OpenPGP bytestring to a hexdigit fingerprint"
        # New GnuTLS "datum" with the OpenPGP public key
        datum = (gnutls.library.types
                 .gnutls_datum_t(ctypes.cast(ctypes.c_char_p(openpgp),
                                             ctypes.POINTER
                                             (ctypes.c_ubyte)),
                                 ctypes.c_uint(len(openpgp))))
        # New empty GnuTLS certificate
        crt = gnutls.library.types.gnutls_openpgp_crt_t()
        (gnutls.library.functions
         .gnutls_openpgp_crt_init(ctypes.byref(crt)))
        # Import the OpenPGP public key into the certificate
        (gnutls.library.functions
         .gnutls_openpgp_crt_import(crt, ctypes.byref(datum),
                                    gnutls.library.constants
                                    .GNUTLS_OPENPGP_FMT_RAW))
        # Verify the self signature in the key
        crtverify = ctypes.c_uint()
        (gnutls.library.functions
         .gnutls_openpgp_crt_verify_self(crt, 0,
                                         ctypes.byref(crtverify)))
        if crtverify.value != 0:
            gnutls.library.functions.gnutls_openpgp_crt_deinit(crt)
            raise (gnutls.errors.CertificateSecurityError
                   ("Verify failed"))
        # New buffer for the fingerprint
        buf = ctypes.create_string_buffer(20)
        buf_len = ctypes.c_size_t()
        # Get the fingerprint from the certificate into the buffer
        (gnutls.library.functions
         .gnutls_openpgp_crt_get_fingerprint(crt, ctypes.byref(buf),
                                             ctypes.byref(buf_len)))
        # Deinit the certificate
        gnutls.library.functions.gnutls_openpgp_crt_deinit(crt)
        # Convert the buffer to a Python bytestring
        fpr = ctypes.string_at(buf, buf_len.value)
        # Convert the bytestring to hexadecimal notation
        hex_fpr = binascii.hexlify(fpr).upper()
        return hex_fpr


class MultiprocessingMixIn(object):
    """Like socketserver.ThreadingMixIn, but with multiprocessing"""
    def sub_process_main(self, request, address):
        try:
            self.finish_request(request, address)
        except Exception:
            self.handle_error(request, address)
        self.close_request(request)
    
    def process_request(self, request, address):
        """Start a new process to process the request."""
        proc = multiprocessing.Process(target = self.sub_process_main,
                                       args = (request,
                                               address))
        proc.start()
        return proc


class MultiprocessingMixInWithPipe(MultiprocessingMixIn, object):
    """ adds a pipe to the MixIn """
    def process_request(self, request, client_address):
        """Overrides and wraps the original process_request().
        
        This function creates a new pipe in self.pipe
        """
        parent_pipe, self.child_pipe = multiprocessing.Pipe()
        
        proc = MultiprocessingMixIn.process_request(self, request,
                                                    client_address)
        self.child_pipe.close()
        self.add_pipe(parent_pipe, proc)
    
    def add_pipe(self, parent_pipe, proc):
        """Dummy function; override as necessary"""
        raise NotImplementedError


class IPv6_TCPServer(MultiprocessingMixInWithPipe,
                     socketserver.TCPServer, object):
    """IPv6-capable TCP server.  Accepts 'None' as address and/or port
    
    Attributes:
        enabled:        Boolean; whether this server is activated yet
        interface:      None or a network interface name (string)
        use_ipv6:       Boolean; to use IPv6 or not
    """
    def __init__(self, server_address, RequestHandlerClass,
                 interface=None, use_ipv6=True):
        self.interface = interface
        if use_ipv6:
            self.address_family = socket.AF_INET6
        socketserver.TCPServer.__init__(self, server_address,
                                        RequestHandlerClass)
    def server_bind(self):
        """This overrides the normal server_bind() function
        to bind to an interface if one was specified, and also NOT to
        bind to an address or port if they were not specified."""
        if self.interface is not None:
            if SO_BINDTODEVICE is None:
                logger.error("SO_BINDTODEVICE does not exist;"
                             " cannot bind to interface %s",
                             self.interface)
            else:
                try:
                    self.socket.setsockopt(socket.SOL_SOCKET,
                                           SO_BINDTODEVICE,
                                           str(self.interface
                                               + '\0'))
                except socket.error as error:
                    if error[0] == errno.EPERM:
                        logger.error("No permission to"
                                     " bind to interface %s",
                                     self.interface)
                    elif error[0] == errno.ENOPROTOOPT:
                        logger.error("SO_BINDTODEVICE not available;"
                                     " cannot bind to interface %s",
                                     self.interface)
                    else:
                        raise
        # Only bind(2) the socket if we really need to.
        if self.server_address[0] or self.server_address[1]:
            if not self.server_address[0]:
                if self.address_family == socket.AF_INET6:
                    any_address = "::" # in6addr_any
                else:
                    any_address = socket.INADDR_ANY
                self.server_address = (any_address,
                                       self.server_address[1])
            elif not self.server_address[1]:
                self.server_address = (self.server_address[0],
                                       0)
#                 if self.interface:
#                     self.server_address = (self.server_address[0],
#                                            0, # port
#                                            0, # flowinfo
#                                            if_nametoindex
#                                            (self.interface))
            return socketserver.TCPServer.server_bind(self)


class MandosServer(IPv6_TCPServer):
    """Mandos server.
    
    Attributes:
        clients:        set of Client objects
        gnutls_priority GnuTLS priority string
        use_dbus:       Boolean; to emit D-Bus signals or not
    
    Assumes a gobject.MainLoop event loop.
    """
    def __init__(self, server_address, RequestHandlerClass,
                 interface=None, use_ipv6=True, clients=None,
                 gnutls_priority=None, use_dbus=True):
        self.enabled = False
        self.clients = clients
        if self.clients is None:
            self.clients = {}
        self.use_dbus = use_dbus
        self.gnutls_priority = gnutls_priority
        IPv6_TCPServer.__init__(self, server_address,
                                RequestHandlerClass,
                                interface = interface,
                                use_ipv6 = use_ipv6)
    def server_activate(self):
        if self.enabled:
            return socketserver.TCPServer.server_activate(self)
    
    def enable(self):
        self.enabled = True
    
    def add_pipe(self, parent_pipe, proc):
        # Call "handle_ipc" for both data and EOF events
        gobject.io_add_watch(parent_pipe.fileno(),
                             gobject.IO_IN | gobject.IO_HUP,
                             functools.partial(self.handle_ipc,
                                               parent_pipe =
                                               parent_pipe,
                                               proc = proc))
    
    def handle_ipc(self, source, condition, parent_pipe=None,
                   proc = None, client_object=None):
        condition_names = {
            gobject.IO_IN: "IN",   # There is data to read.
            gobject.IO_OUT: "OUT", # Data can be written (without
                                    # blocking).
            gobject.IO_PRI: "PRI", # There is urgent data to read.
            gobject.IO_ERR: "ERR", # Error condition.
            gobject.IO_HUP: "HUP"  # Hung up (the connection has been
                                    # broken, usually for pipes and
                                    # sockets).
            }
        conditions_string = ' | '.join(name
                                       for cond, name in
                                       condition_names.iteritems()
                                       if cond & condition)
        # error, or the other end of multiprocessing.Pipe has closed
        if condition & (gobject.IO_ERR | condition & gobject.IO_HUP):
            # Wait for other process to exit
            proc.join()
            return False
        
        # Read a request from the child
        request = parent_pipe.recv()
        command = request[0]
        
        if command == 'init':
            fpr = request[1]
            address = request[2]
            
            for c in self.clients.itervalues():
                if c.fingerprint == fpr:
                    client = c
                    break
            else:
                logger.info("Client not found for fingerprint: %s, ad"
                            "dress: %s", fpr, address)
                if self.use_dbus:
                    # Emit D-Bus signal
                    mandos_dbus_service.ClientNotFound(fpr,
                                                       address[0])
                parent_pipe.send(False)
                return False
            
            gobject.io_add_watch(parent_pipe.fileno(),
                                 gobject.IO_IN | gobject.IO_HUP,
                                 functools.partial(self.handle_ipc,
                                                   parent_pipe =
                                                   parent_pipe,
                                                   proc = proc,
                                                   client_object =
                                                   client))
            parent_pipe.send(True)
            # remove the old hook in favor of the new above hook on
            # same fileno
            return False
        if command == 'funcall':
            funcname = request[1]
            args = request[2]
            kwargs = request[3]
            
            parent_pipe.send(('data', getattr(client_object,
                                              funcname)(*args,
                                                         **kwargs)))
        
        if command == 'getattr':
            attrname = request[1]
            if callable(client_object.__getattribute__(attrname)):
                parent_pipe.send(('function',))
            else:
                parent_pipe.send(('data', client_object
                                  .__getattribute__(attrname)))
        
        if command == 'setattr':
            attrname = request[1]
            value = request[2]
            setattr(client_object, attrname, value)
        
        return True


def string_to_delta(interval):
    """Parse a string and return a datetime.timedelta
    
    >>> string_to_delta('7d')
    datetime.timedelta(7)
    >>> string_to_delta('60s')
    datetime.timedelta(0, 60)
    >>> string_to_delta('60m')
    datetime.timedelta(0, 3600)
    >>> string_to_delta('24h')
    datetime.timedelta(1)
    >>> string_to_delta('1w')
    datetime.timedelta(7)
    >>> string_to_delta('5m 30s')
    datetime.timedelta(0, 330)
    """
    timevalue = datetime.timedelta(0)
    for s in interval.split():
        try:
            suffix = unicode(s[-1])
            value = int(s[:-1])
            if suffix == "d":
                delta = datetime.timedelta(value)
            elif suffix == "s":
                delta = datetime.timedelta(0, value)
            elif suffix == "m":
                delta = datetime.timedelta(0, 0, 0, 0, value)
            elif suffix == "h":
                delta = datetime.timedelta(0, 0, 0, 0, 0, value)
            elif suffix == "w":
                delta = datetime.timedelta(0, 0, 0, 0, 0, 0, value)
            else:
                raise ValueError("Unknown suffix %r" % suffix)
        except (ValueError, IndexError) as e:
            raise ValueError(*(e.args))
        timevalue += delta
    return timevalue


def daemon(nochdir = False, noclose = False):
    """See daemon(3).  Standard BSD Unix function.
    
    This should really exist as os.daemon, but it doesn't (yet)."""
    if os.fork():
        sys.exit()
    os.setsid()
    if not nochdir:
        os.chdir("/")
    if os.fork():
        sys.exit()
    if not noclose:
        # Close all standard open file descriptors
        null = os.open(os.devnull, os.O_NOCTTY | os.O_RDWR)
        if not stat.S_ISCHR(os.fstat(null).st_mode):
            raise OSError(errno.ENODEV,
                          "%s not a character device"
                          % os.devnull)
        os.dup2(null, sys.stdin.fileno())
        os.dup2(null, sys.stdout.fileno())
        os.dup2(null, sys.stderr.fileno())
        if null > 2:
            os.close(null)


def main():
    
    ##################################################################
    # Parsing of options, both command line and config file
    
    parser = argparse.ArgumentParser()
    parser.add_argument("-v", "--version", action="version",
                        version = "%%(prog)s %s" % version,
                        help="show version number and exit")
    parser.add_argument("-i", "--interface", metavar="IF",
                        help="Bind to interface IF")
    parser.add_argument("-a", "--address",
                        help="Address to listen for requests on")
    parser.add_argument("-p", "--port", type=int,
                        help="Port number to receive requests on")
    parser.add_argument("--check", action="store_true",
                        help="Run self-test")
    parser.add_argument("--debug", action="store_true",
                        help="Debug mode; run in foreground and log"
                        " to terminal")
    parser.add_argument("--debuglevel", metavar="LEVEL",
                        help="Debug level for stdout output")
    parser.add_argument("--priority", help="GnuTLS"
                        " priority string (see GnuTLS documentation)")
    parser.add_argument("--servicename",
                        metavar="NAME", help="Zeroconf service name")
    parser.add_argument("--configdir",
                        default="/etc/mandos", metavar="DIR",
                        help="Directory to search for configuration"
                        " files")
    parser.add_argument("--no-dbus", action="store_false",
                        dest="use_dbus", help="Do not provide D-Bus"
                        " system bus interface")
    parser.add_argument("--no-ipv6", action="store_false",
                        dest="use_ipv6", help="Do not use IPv6")
    parser.add_argument("--no-restore", action="store_false",
                        dest="restore", help="Do not restore stored"
                        " state")
    parser.add_argument("--statedir", metavar="DIR",
                        help="Directory to save/restore state in")
    
    options = parser.parse_args()
    
    if options.check:
        import doctest
        doctest.testmod()
        sys.exit()
    
    # Default values for config file for server-global settings
    server_defaults = { "interface": "",
                        "address": "",
                        "port": "",
                        "debug": "False",
                        "priority":
                        "SECURE256:!CTYPE-X.509:+CTYPE-OPENPGP",
                        "servicename": "Mandos",
                        "use_dbus": "True",
                        "use_ipv6": "True",
                        "debuglevel": "",
                        "restore": "True",
                        "statedir": "/var/lib/mandos"
                        }
    
    # Parse config file for server-global settings
    server_config = configparser.SafeConfigParser(server_defaults)
    del server_defaults
    server_config.read(os.path.join(options.configdir,
                                    "mandos.conf"))
    # Convert the SafeConfigParser object to a dict
    server_settings = server_config.defaults()
    # Use the appropriate methods on the non-string config options
    for option in ("debug", "use_dbus", "use_ipv6"):
        server_settings[option] = server_config.getboolean("DEFAULT",
                                                           option)
    if server_settings["port"]:
        server_settings["port"] = server_config.getint("DEFAULT",
                                                       "port")
    del server_config
    
    # Override the settings from the config file with command line
    # options, if set.
    for option in ("interface", "address", "port", "debug",
                   "priority", "servicename", "configdir",
                   "use_dbus", "use_ipv6", "debuglevel", "restore",
                   "statedir"):
        value = getattr(options, option)
        if value is not None:
            server_settings[option] = value
    del options
    # Force all strings to be unicode
    for option in server_settings.keys():
        if type(server_settings[option]) is str:
            server_settings[option] = unicode(server_settings[option])
    # Now we have our good server settings in "server_settings"
    
    ##################################################################
    
    # For convenience
    debug = server_settings["debug"]
    debuglevel = server_settings["debuglevel"]
    use_dbus = server_settings["use_dbus"]
    use_ipv6 = server_settings["use_ipv6"]
    stored_state_path = os.path.join(server_settings["statedir"],
                                     stored_state_file)
    
    if debug:
        initlogger(debug, logging.DEBUG)
    else:
        if not debuglevel:
            initlogger(debug)
        else:
            level = getattr(logging, debuglevel.upper())
            initlogger(debug, level)
    
    if server_settings["servicename"] != "Mandos":
        syslogger.setFormatter(logging.Formatter
                               ('Mandos (%s) [%%(process)d]:'
                                ' %%(levelname)s: %%(message)s'
                                % server_settings["servicename"]))
    
    # Parse config file with clients
    client_config = configparser.SafeConfigParser(Client
                                                  .client_defaults)
    client_config.read(os.path.join(server_settings["configdir"],
                                    "clients.conf"))
    
    global mandos_dbus_service
    mandos_dbus_service = None
    
    tcp_server = MandosServer((server_settings["address"],
                               server_settings["port"]),
                              ClientHandler,
                              interface=(server_settings["interface"]
                                         or None),
                              use_ipv6=use_ipv6,
                              gnutls_priority=
                              server_settings["priority"],
                              use_dbus=use_dbus)
    if not debug:
        pidfilename = "/var/run/mandos.pid"
        try:
            pidfile = open(pidfilename, "w")
        except IOError:
            logger.error("Could not open file %r", pidfilename)
    
    for name in ("_mandos", "mandos", "nobody"):
        try:
            uid = pwd.getpwnam(name).pw_uid
            gid = pwd.getpwnam(name).pw_gid
            break
        except KeyError:
            continue
    else:
        uid = 65534
        gid = 65534
    try:
        os.setgid(gid)
        os.setuid(uid)
    except OSError as error:
        if error[0] != errno.EPERM:
            raise error
    
    if debug:
        # Enable all possible GnuTLS debugging
        
        # "Use a log level over 10 to enable all debugging options."
        # - GnuTLS manual
        gnutls.library.functions.gnutls_global_set_log_level(11)
        
        @gnutls.library.types.gnutls_log_func
        def debug_gnutls(level, string):
            logger.debug("GnuTLS: %s", string[:-1])
        
        (gnutls.library.functions
         .gnutls_global_set_log_function(debug_gnutls))
        
        # Redirect stdin so all checkers get /dev/null
        null = os.open(os.devnull, os.O_NOCTTY | os.O_RDWR)
        os.dup2(null, sys.stdin.fileno())
        if null > 2:
            os.close(null)
    
    # Need to fork before connecting to D-Bus
    if not debug:
        # Close all input and output, do double fork, etc.
        daemon()
    
    gobject.threads_init()
    
    global main_loop
    # From the Avahi example code
    DBusGMainLoop(set_as_default=True)
    main_loop = gobject.MainLoop()
    bus = dbus.SystemBus()
    # End of Avahi example code
    if use_dbus:
        try:
            bus_name = dbus.service.BusName("se.recompile.Mandos",
                                            bus, do_not_queue=True)
            old_bus_name = (dbus.service.BusName
                            ("se.bsnet.fukt.Mandos", bus,
                             do_not_queue=True))
        except dbus.exceptions.NameExistsException as e:
            logger.error(unicode(e) + ", disabling D-Bus")
            use_dbus = False
            server_settings["use_dbus"] = False
            tcp_server.use_dbus = False
    protocol = avahi.PROTO_INET6 if use_ipv6 else avahi.PROTO_INET
    service = AvahiServiceToSyslog(name =
                                   server_settings["servicename"],
                                   servicetype = "_mandos._tcp",
                                   protocol = protocol, bus = bus)
    if server_settings["interface"]:
        service.interface = (if_nametoindex
                             (str(server_settings["interface"])))
    
    global multiprocessing_manager
    multiprocessing_manager = multiprocessing.Manager()
    
    client_class = Client
    if use_dbus:
        client_class = functools.partial(ClientDBusTransitional,
                                         bus = bus)
    
    client_settings = Client.config_parser(client_config)
    old_client_settings = {}
    clients_data = {}
    
    # Get client data and settings from last running state.
    if server_settings["restore"]:
        try:
            with open(stored_state_path, "rb") as stored_state:
                clients_data, old_client_settings = (pickle.load
                                                     (stored_state))
            os.remove(stored_state_path)
        except IOError as e:
            logger.warning("Could not load persistent state: {0}"
                           .format(e))
            if e.errno != errno.ENOENT:
                raise
        except EOFError as e:
            logger.warning("Could not load persistent state: "
                           "EOFError: {0}".format(e))
    
    with PGPEngine() as pgp:
        for client_name, client in clients_data.iteritems():
            # Decide which value to use after restoring saved state.
            # We have three different values: Old config file,
            # new config file, and saved state.
            # New config value takes precedence if it differs from old
            # config value, otherwise use saved state.
            for name, value in client_settings[client_name].items():
                try:
                    # For each value in new config, check if it
                    # differs from the old config value (Except for
                    # the "secret" attribute)
                    if (name != "secret" and
                        value != old_client_settings[client_name]
                        [name]):
                        client[name] = value
                except KeyError:
                    pass
            
            # Clients who has passed its expire date can still be
            # enabled if its last checker was successful.  Clients
            # whose checker succeeded before we stored its state is
            # assumed to have successfully run all checkers during
            # downtime.
            if client["enabled"]:
                if datetime.datetime.utcnow() >= client["expires"]:
                    if not client["last_checked_ok"]:
                        logger.warning(
                            "disabling client {0} - Client never "
                            "performed a successful checker"
                            .format(client_name))
                        client["enabled"] = False
                    elif client["last_checker_status"] != 0:
                        logger.warning(
                            "disabling client {0} - Client "
                            "last checker failed with error code {1}"
                            .format(client_name,
                                    client["last_checker_status"]))
                        client["enabled"] = False
                    else:
                        client["expires"] = (datetime.datetime
                                             .utcnow()
                                             + client["timeout"])
                        logger.debug("Last checker succeeded,"
                                     " keeping {0} enabled"
                                     .format(client_name))
            try:
                client["secret"] = (
                    pgp.decrypt(client["encrypted_secret"],
                                client_settings[client_name]
                                ["secret"]))
            except PGPError:
                # If decryption fails, we use secret from new settings
                logger.debug("Failed to decrypt {0} old secret"
                             .format(client_name))
                client["secret"] = (
                    client_settings[client_name]["secret"])

    
    # Add/remove clients based on new changes made to config
    for client_name in (set(old_client_settings)
                        - set(client_settings)):
        del clients_data[client_name]
    for client_name in (set(client_settings)
                        - set(old_client_settings)):
        clients_data[client_name] = client_settings[client_name]

    # Create all client objects
    for client_name, client in clients_data.iteritems():
        tcp_server.clients[client_name] = client_class(
            name = client_name, settings = client)
    
    if not tcp_server.clients:
        logger.warning("No clients defined")
        
    if not debug:
        try:
            with pidfile:
                pid = os.getpid()
                pidfile.write(str(pid) + "\n".encode("utf-8"))
            del pidfile
        except IOError:
            logger.error("Could not write to file %r with PID %d",
                         pidfilename, pid)
        except NameError:
            # "pidfile" was never created
            pass
        del pidfilename
        signal.signal(signal.SIGINT, signal.SIG_IGN)
    
    signal.signal(signal.SIGHUP, lambda signum, frame: sys.exit())
    signal.signal(signal.SIGTERM, lambda signum, frame: sys.exit())
    
    if use_dbus:
        class MandosDBusService(DBusObjectWithProperties):
            """A D-Bus proxy object"""
            def __init__(self):
                dbus.service.Object.__init__(self, bus, "/")
            _interface = "se.recompile.Mandos"
            
            @dbus_interface_annotations(_interface)
            def _foo(self):
                return { "org.freedesktop.DBus.Property"
                         ".EmitsChangedSignal":
                             "false"}
            
            @dbus.service.signal(_interface, signature="o")
            def ClientAdded(self, objpath):
                "D-Bus signal"
                pass
            
            @dbus.service.signal(_interface, signature="ss")
            def ClientNotFound(self, fingerprint, address):
                "D-Bus signal"
                pass
            
            @dbus.service.signal(_interface, signature="os")
            def ClientRemoved(self, objpath, name):
                "D-Bus signal"
                pass
            
            @dbus.service.method(_interface, out_signature="ao")
            def GetAllClients(self):
                "D-Bus method"
                return dbus.Array(c.dbus_object_path
                                  for c in
                                  tcp_server.clients.itervalues())
            
            @dbus.service.method(_interface,
                                 out_signature="a{oa{sv}}")
            def GetAllClientsWithProperties(self):
                "D-Bus method"
                return dbus.Dictionary(
                    ((c.dbus_object_path, c.GetAll(""))
                     for c in tcp_server.clients.itervalues()),
                    signature="oa{sv}")
            
            @dbus.service.method(_interface, in_signature="o")
            def RemoveClient(self, object_path):
                "D-Bus method"
                for c in tcp_server.clients.itervalues():
                    if c.dbus_object_path == object_path:
                        del tcp_server.clients[c.name]
                        c.remove_from_connection()
                        # Don't signal anything except ClientRemoved
                        c.disable(quiet=True)
                        # Emit D-Bus signal
                        self.ClientRemoved(object_path, c.name)
                        return
                raise KeyError(object_path)
            
            del _interface
        
        class MandosDBusServiceTransitional(MandosDBusService):
            __metaclass__ = AlternateDBusNamesMetaclass
        mandos_dbus_service = MandosDBusServiceTransitional()
    
    def cleanup():
        "Cleanup function; run on exit"
        service.cleanup()
        
        multiprocessing.active_children()
        if not (tcp_server.clients or client_settings):
            return
        
        # Store client before exiting. Secrets are encrypted with key
        # based on what config file has. If config file is
        # removed/edited, old secret will thus be unrecovable.
        clients = {}
        with PGPEngine() as pgp:
            for client in tcp_server.clients.itervalues():
                key = client_settings[client.name]["secret"]
                client.encrypted_secret = pgp.encrypt(client.secret,
                                                      key)
                client_dict = {}
                
                # A list of attributes that can not be pickled
                # + secret.
                exclude = set(("bus", "changedstate", "secret",
                               "checker"))
                for name, typ in (inspect.getmembers
                                  (dbus.service.Object)):
                    exclude.add(name)
                
                client_dict["encrypted_secret"] = (client
                                                   .encrypted_secret)
                for attr in client.client_structure:
                    if attr not in exclude:
                        client_dict[attr] = getattr(client, attr)
                
                clients[client.name] = client_dict
                del client_settings[client.name]["secret"]
        
        try:
            tempfd, tempname = tempfile.mkstemp(suffix=".pickle",
                                                prefix="clients-",
                                                dir=os.path.dirname
                                                (stored_state_path))
            with os.fdopen(tempfd, "wb") as stored_state:
                pickle.dump((clients, client_settings), stored_state)
            os.rename(tempname, stored_state_path)
        except (IOError, OSError) as e:
            logger.warning("Could not save persistent state: {0}"
                           .format(e))
            if not debug:
                try:
                    os.remove(tempname)
                except NameError:
                    pass
            if e.errno not in set((errno.ENOENT, errno.EACCES,
                                   errno.EEXIST)):
                raise e
        
        # Delete all clients, and settings from config
        while tcp_server.clients:
            name, client = tcp_server.clients.popitem()
            if use_dbus:
                client.remove_from_connection()
            # Don't signal anything except ClientRemoved
            client.disable(quiet=True)
            if use_dbus:
                # Emit D-Bus signal
                mandos_dbus_service.ClientRemoved(client
                                                  .dbus_object_path,
                                                  client.name)
        client_settings.clear()
    
    atexit.register(cleanup)
    
    for client in tcp_server.clients.itervalues():
        if use_dbus:
            # Emit D-Bus signal
            mandos_dbus_service.ClientAdded(client.dbus_object_path)
        # Need to initiate checking of clients
        if client.enabled:
            client.init_checker()
    
    tcp_server.enable()
    tcp_server.server_activate()
    
    # Find out what port we got
    service.port = tcp_server.socket.getsockname()[1]
    if use_ipv6:
        logger.info("Now listening on address %r, port %d,"
                    " flowinfo %d, scope_id %d"
                    % tcp_server.socket.getsockname())
    else:                       # IPv4
        logger.info("Now listening on address %r, port %d"
                    % tcp_server.socket.getsockname())
    
    #service.interface = tcp_server.socket.getsockname()[3]
    
    try:
        # From the Avahi example code
        try:
            service.activate()
        except dbus.exceptions.DBusException as error:
            logger.critical("D-Bus Exception", exc_info=error)
            cleanup()
            sys.exit(1)
        # End of Avahi example code
        
        gobject.io_add_watch(tcp_server.fileno(), gobject.IO_IN,
                             lambda *args, **kwargs:
                             (tcp_server.handle_request
                              (*args[2:], **kwargs) or True))
        
        logger.debug("Starting main loop")
        main_loop.run()
    except AvahiError as error:
        logger.critical("Avahi Error", exc_info=error)
        cleanup()
        sys.exit(1)
    except KeyboardInterrupt:
        if debug:
            print("", file=sys.stderr)
        logger.debug("Server received KeyboardInterrupt")
    logger.debug("Server exiting")
    # Must run before the D-Bus bus name gets deregistered
    cleanup()

if __name__ == '__main__':
    main()
